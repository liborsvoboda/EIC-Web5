{"version":3,"file":"fileUtils.js","names":["_fs","_interopRequireDefault","require","_path","_manualPromise","_zipBundle","e","__esModule","default","fileUploadSizeLimit","exports","existsAsync","path","Promise","resolve","fs","stat","err","mkdirIfNeeded","filePath","promises","mkdir","dirname","recursive","catch","removeFolders","dirs","all","map","dir","rm","force","maxRetries","canAccessFile","file","accessSync","copyFileAndMakeWritable","from","to","copyFile","chmod","sanitizeForFilePath","s","replace","toPosixPath","aPath","split","sep","join","posix","SerializedFS","constructor","_buffers","Map","_error","_operations","_operationsDone","ManualPromise","_appendOperation","op","writeFile","content","skipIfExists","delete","appendFile","text","flush","has","set","get","push","_flushFile","buffer","undefined","syncAndGetError","keys","zip","entries","zipFileName","last","length","isDone","_performOperations","shift","_performOperation","flag","zipFile","yazl","ZipFile","result","on","error","reject","entry","addFile","value","name","end","outputStream","pipe","createWriteStream"],"sources":["../../src/utils/fileUtils.ts"],"sourcesContent":["/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport { ManualPromise } from './manualPromise';\nimport type { EventEmitter } from 'events';\nimport { yazl } from '../zipBundle';\n\nexport const fileUploadSizeLimit = 50 * 1024 * 1024;\n\nexport const existsAsync = (path: string): Promise<boolean> => new Promise(resolve => fs.stat(path, err => resolve(!err)));\n\nexport async function mkdirIfNeeded(filePath: string) {\n  // This will harmlessly throw on windows if the dirname is the root directory.\n  await fs.promises.mkdir(path.dirname(filePath), { recursive: true }).catch(() => {});\n}\n\nexport async function removeFolders(dirs: string[]): Promise<Error[]> {\n  return await Promise.all(dirs.map((dir: string) =>\n    fs.promises.rm(dir, { recursive: true, force: true, maxRetries: 10 }).catch(e => e)\n  ));\n}\n\nexport function canAccessFile(file: string) {\n  if (!file)\n    return false;\n\n  try {\n    fs.accessSync(file);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport async function copyFileAndMakeWritable(from: string, to: string) {\n  await fs.promises.copyFile(from, to);\n  await fs.promises.chmod(to, 0o664);\n}\n\nexport function sanitizeForFilePath(s: string) {\n  return s.replace(/[\\x00-\\x2C\\x2E-\\x2F\\x3A-\\x40\\x5B-\\x60\\x7B-\\x7F]+/g, '-');\n}\n\nexport function toPosixPath(aPath: string): string {\n  return aPath.split(path.sep).join(path.posix.sep);\n}\n\ntype NameValue = { name: string, value: string };\ntype SerializedFSOperation = {\n  op: 'mkdir', dir: string,\n} | {\n  op: 'writeFile', file: string, content: string | Buffer, skipIfExists?: boolean,\n} | {\n  op: 'appendFile', file: string, content: string,\n} | {\n  op: 'copyFile', from: string, to: string,\n} | {\n  op: 'zip', entries: NameValue[], zipFileName: string,\n};\n\nexport class SerializedFS {\n  private _buffers = new Map<string, string[]>(); // Should never be accessed from within appendOperation.\n  private _error: Error | undefined;\n  private _operations: SerializedFSOperation[] = [];\n  private _operationsDone: ManualPromise<void>;\n\n  constructor() {\n    this._operationsDone = new ManualPromise();\n    this._operationsDone.resolve();  // No operations scheduled yet.\n  }\n\n  mkdir(dir: string) {\n    this._appendOperation({ op: 'mkdir', dir });\n  }\n\n  writeFile(file: string, content: string | Buffer, skipIfExists?: boolean) {\n    this._buffers.delete(file); // No need to flush the buffer since we'll overwrite anyway.\n    this._appendOperation({ op: 'writeFile', file, content, skipIfExists });\n  }\n\n  appendFile(file: string, text: string, flush?: boolean) {\n    if (!this._buffers.has(file))\n      this._buffers.set(file, []);\n    this._buffers.get(file)!.push(text);\n    if (flush)\n      this._flushFile(file);\n  }\n\n  private _flushFile(file: string) {\n    const buffer = this._buffers.get(file);\n    if (buffer === undefined)\n      return;\n    const content = buffer.join('');\n    this._buffers.delete(file);\n    this._appendOperation({ op: 'appendFile', file, content });\n  }\n\n  copyFile(from: string, to: string) {\n    this._flushFile(from);\n    this._buffers.delete(to); // No need to flush the buffer since we'll overwrite anyway.\n    this._appendOperation({ op: 'copyFile', from, to });\n  }\n\n  async syncAndGetError() {\n    for (const file of this._buffers.keys())\n      this._flushFile(file);\n    await this._operationsDone;\n    return this._error;\n  }\n\n  zip(entries: NameValue[], zipFileName: string) {\n    for (const file of this._buffers.keys())\n      this._flushFile(file);\n\n    // Chain the export operation against write operations,\n    // so that files do not change during the export.\n    this._appendOperation({ op: 'zip', entries, zipFileName });\n  }\n\n  // This method serializes all writes to the trace.\n  private _appendOperation(op: SerializedFSOperation): void {\n    const last = this._operations[this._operations.length - 1];\n    if (last?.op === 'appendFile' && op.op === 'appendFile' && last.file === op.file) {\n      // Merge pending appendFile operations for performance.\n      last.content += op.content;\n      return;\n    }\n\n    this._operations.push(op);\n    if (this._operationsDone.isDone())\n      this._performOperations();\n  }\n\n  private async _performOperations() {\n    this._operationsDone = new ManualPromise();\n    while (this._operations.length) {\n      const op = this._operations.shift()!;\n      // Ignore all operations after the first error.\n      if (this._error)\n        continue;\n      try {\n        await this._performOperation(op);\n      } catch (e) {\n        this._error = e;\n      }\n    }\n    this._operationsDone.resolve();\n  }\n\n  private async _performOperation(op: SerializedFSOperation) {\n    switch (op.op) {\n      case 'mkdir': {\n        await fs.promises.mkdir(op.dir, { recursive: true });\n        return;\n      }\n      case 'writeFile': {\n        // Note: 'wx' flag only writes when the file does not exist.\n        // See https://nodejs.org/api/fs.html#file-system-flags.\n        // This way tracing never have to write the same resource twice.\n        if (op.skipIfExists)\n          await fs.promises.writeFile(op.file, op.content, { flag: 'wx' }).catch(() => {});\n        else\n          await fs.promises.writeFile(op.file, op.content);\n        return;\n      }\n      case 'copyFile': {\n        await fs.promises.copyFile(op.from, op.to);\n        return;\n      }\n      case 'appendFile': {\n        await fs.promises.appendFile(op.file, op.content);\n        return;\n      }\n      case 'zip': {\n        const zipFile = new yazl.ZipFile();\n        const result = new ManualPromise<void>();\n        (zipFile as any as EventEmitter).on('error', error => result.reject(error));\n        for (const entry of op.entries)\n          zipFile.addFile(entry.value, entry.name);\n        zipFile.end();\n        zipFile.outputStream\n            .pipe(fs.createWriteStream(op.zipFileName))\n            .on('close', () => result.resolve())\n            .on('error', error => result.reject(error));\n        await result;\n        return;\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]}