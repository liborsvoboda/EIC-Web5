{"version":3,"file":"_hyperscript_web.esm.js","sources":["../src/lib/utils.js","../src/lib/core.js","../src/lib/web.js","../src/web/_hyperscript_web.js"],"sourcesContent":["\n/**\n * mergeObjects combines the keys from obj2 into obj2, then returns obj1\n *\n * @param {object} obj1\n * @param {object} obj2\n * @returns object\n */\nexport function mergeObjects(obj1, obj2) {\n\tfor (var key in obj2) {\n\t\tif (obj2.hasOwnProperty(key)) {\n\t\t\tobj1[key] = obj2[key];\n\t\t}\n\t}\n\treturn obj1;\n}\n\nexport function getOrInitObject(root, prop) {\n\tvar value = root[prop];\n\tif (value) {\n\t\treturn value;\n\t} else {\n\t\tvar newObj = {};\n\t\troot[prop] = newObj;\n\t\treturn newObj;\n\t}\n}\n\n/**\n * parseJSON parses a JSON string into a corresponding value.  If the\n * value passed in is not valid JSON, then it logs an error and returns `null`.\n *\n * @param {string} jString\n * @returns any\n */\nexport function parseJSON(jString) {\n\ttry {\n\t\treturn JSON.parse(jString);\n\t} catch (error) {\n\t\tlogError(error);\n\t\treturn null;\n\t}\n}\n\n/**\n * logError writes an error message to the Javascript console.  It can take any\n * value, but msg should commonly be a simple string.\n * @param {*} msg\n */\nexport function logError(msg) {\n\tif (console.error) {\n\t\tconsole.error(msg);\n\t} else if (console.log) {\n\t\tconsole.log(\"ERROR: \", msg);\n\t}\n}\n\n// TODO: JSDoc description of what's happening here\nexport function varargConstructor(Cls, args) {\n\treturn new (Cls.bind.apply(Cls, [Cls].concat(args)))();\n}\n","///=========================================================================\n/// This module provides the core runtime and grammar for hyperscript\n///=========================================================================\n\nimport {getOrInitObject, mergeObjects, parseJSON, varargConstructor} from \"./utils.js\";\n\n\n/**\n * @type {HyperscriptObject}\n */\nlet _hyperscript\n\nvar globalScope = globalThis;\n\n//====================================================================\n// Standard library\n//====================================================================\n\nclass ElementCollection {\n\tconstructor(css, relativeToElement) {\n\t\tthis._css = css;\n\t\tthis.relativeToElement = relativeToElement;\n\t}\n\n\tget css() {\n\t\treturn _runtime.escapeSelector(this._css);\n\t}\n\n\tget className() {\n\t\treturn this._css.substr(1);\n\t}\n\n\tget id() {\n\t\treturn this.className();\n\t}\n\n\tcontains(elt) {\n\t\tfor (let element of this) {\n\t\t\tif (element.contains(elt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn _runtime.getRootNode(this.relativeToElement)\n\t\t\t.querySelectorAll(this.css)\n\t\t\t[Symbol.iterator]();\n\t}\n}\n\n//====================================================================\n// Lexer\n//====================================================================\n\n/** @type LexerObject */\nvar _lexer = (function () {\n\tvar OP_TABLE = {\n\t\t\"+\": \"PLUS\",\n\t\t\"-\": \"MINUS\",\n\t\t\"*\": \"MULTIPLY\",\n\t\t\"/\": \"DIVIDE\",\n\t\t\".\": \"PERIOD\",\n\t\t\"..\": \"ELLIPSIS\",\n\t\t\"\\\\\": \"BACKSLASH\",\n\t\t\":\": \"COLON\",\n\t\t\"%\": \"PERCENT\",\n\t\t\"|\": \"PIPE\",\n\t\t\"!\": \"EXCLAMATION\",\n\t\t\"?\": \"QUESTION\",\n\t\t\"#\": \"POUND\",\n\t\t\"&\": \"AMPERSAND\",\n\t\t$: \"DOLLAR\",\n\t\t\";\": \"SEMI\",\n\t\t\",\": \"COMMA\",\n\t\t\"(\": \"L_PAREN\",\n\t\t\")\": \"R_PAREN\",\n\t\t\"<\": \"L_ANG\",\n\t\t\">\": \"R_ANG\",\n\t\t\"<=\": \"LTE_ANG\",\n\t\t\">=\": \"GTE_ANG\",\n\t\t\"==\": \"EQ\",\n\t\t\"===\": \"EQQ\",\n\t\t\"!=\": \"NEQ\",\n\t\t\"!==\": \"NEQQ\",\n\t\t\"{\": \"L_BRACE\",\n\t\t\"}\": \"R_BRACE\",\n\t\t\"[\": \"L_BRACKET\",\n\t\t\"]\": \"R_BRACKET\",\n\t\t\"=\": \"EQUALS\",\n\t};\n\n\t/**\n\t * isValidCSSClassChar returns `true` if the provided character is valid in a CSS class.\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isValidCSSClassChar(c) {\n\t\treturn isAlpha(c) || isNumeric(c) || c === \"-\" || c === \"_\" || c === \":\";\n\t}\n\n\t/**\n\t * isValidCSSIDChar returns `true` if the provided character is valid in a CSS ID\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isValidCSSIDChar(c) {\n\t\treturn isAlpha(c) || isNumeric(c) || c === \"-\" || c === \"_\" || c === \":\";\n\t}\n\n\t/**\n\t * isWhitespace returns `true` if the provided character is whitespace.\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isWhitespace(c) {\n\t\treturn c === \" \" || c === \"\\t\" || isNewline(c);\n\t}\n\n\t/**\n\t * positionString returns a string representation of a Token's line and column details.\n\t * @param {Token} token\n\t * @returns string\n\t */\n\tfunction positionString(token) {\n\t\treturn \"[Line: \" + token.line + \", Column: \" + token.column + \"]\";\n\t}\n\n\t/**\n\t * isNewline returns `true` if the provided character is a carrage return or newline\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isNewline(c) {\n\t\treturn c === \"\\r\" || c === \"\\n\";\n\t}\n\n\t/**\n\t * isNumeric returns `true` if the provided character is a number (0-9)\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isNumeric(c) {\n\t\treturn c >= \"0\" && c <= \"9\";\n\t}\n\n\t/**\n\t * isAlpha returns `true` if the provided character is a letter in the alphabet\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isAlpha(c) {\n\t\treturn (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\");\n\t}\n\n\t/**\n\t * @param {string} c\n\t * @param {boolean} [dollarIsOp]\n\t * @returns boolean\n\t */\n\tfunction isIdentifierChar(c, dollarIsOp) {\n\t\treturn c === \"_\" || c === \"$\";\n\t}\n\n\t/**\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isReservedChar(c) {\n\t\treturn c === \"`\" || c === \"^\";\n\t}\n\n\t/**\n\t * @param {Token[]} tokens\n\t * @param {Token[]} consumed\n\t * @param {string} source\n\t * @returns {TokensObject}\n\t */\n\tfunction makeTokensObject(tokens, consumed, source) {\n\t\tconsumeWhitespace(); // consume initial whitespace\n\n\t\t/** @type Token | null */\n\t\tvar _lastConsumed = null;\n\n\t\tfunction consumeWhitespace() {\n\t\t\twhile (token(0, true).type === \"WHITESPACE\") {\n\t\t\t\tconsumed.push(tokens.shift());\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {TokensObject} tokens\n\t\t * @param {*} error\n\t\t */\n\t\tfunction raiseError(tokens, error) {\n\t\t\t_parser.raiseParseError(tokens, error);\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction requireOpToken(value) {\n\t\t\tvar token = matchOpToken(value);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\traiseError(this, \"Expected '\" + value + \"' but found '\" + currentToken().value + \"'\");\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} op1\n\t\t * @param {string} [op2]\n\t\t * @param {string} [op3]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchAnyOpToken(op1, op2, op3) {\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tvar opToken = arguments[i];\n\t\t\t\tvar match = matchOpToken(opToken);\n\t\t\t\tif (match) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} op1\n\t\t * @param {string} [op2]\n\t\t * @param {string} [op3]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchAnyToken(op1, op2, op3) {\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tvar opToken = arguments[i];\n\t\t\t\tvar match = matchToken(opToken);\n\t\t\t\tif (match) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchOpToken(value) {\n\t\t\tif (currentToken() && currentToken().op && currentToken().value === value) {\n\t\t\t\treturn consumeToken();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} type1\n\t\t * @param {string} [type2]\n\t\t * @param {string} [type3]\n\t\t * @param {string} [type4]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction requireTokenType(type1, type2, type3, type4) {\n\t\t\tvar token = matchTokenType(type1, type2, type3, type4);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\traiseError(this, \"Expected one of \" + JSON.stringify([type1, type2, type3]));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} type1\n\t\t * @param {string} [type2]\n\t\t * @param {string} [type3]\n\t\t * @param {string} [type4]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchTokenType(type1, type2, type3, type4) {\n\t\t\tif (\n\t\t\t\tcurrentToken() &&\n\t\t\t\tcurrentToken().type &&\n\t\t\t\t[type1, type2, type3, type4].indexOf(currentToken().type) >= 0\n\t\t\t) {\n\t\t\t\treturn consumeToken();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @param {string} [type]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction requireToken(value, type) {\n\t\t\tvar token = matchToken(value, type);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\traiseError(this, \"Expected '\" + value + \"' but found '\" + currentToken().value + \"'\");\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @param {string} [type]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchToken(value, type) {\n\t\t\tif (follows.indexOf(value) !== -1) {\n\t\t\t\treturn; // disallowed token here\n\t\t\t}\n\t\t\tvar type = type || \"IDENTIFIER\";\n\t\t\tif (currentToken() && currentToken().value === value && currentToken().type === type) {\n\t\t\t\treturn consumeToken();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction consumeToken() {\n\t\t\tvar match = tokens.shift();\n\t\t\tconsumed.push(match);\n\t\t\t_lastConsumed = match;\n\t\t\tconsumeWhitespace(); // consume any whitespace\n\t\t\treturn match;\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @param {string} [type]\n\t\t * @returns {Token[]}\n\t\t */\n\t\tfunction consumeUntil(value, type) {\n\t\t\t/** @type Token[] */\n\t\t\tvar tokenList = [];\n\t\t\tvar currentToken = token(0, true);\n\n\t\t\twhile (\n\t\t\t\t(type == null || currentToken.type !== type) &&\n\t\t\t\t(value == null || currentToken.value !== value) &&\n\t\t\t\tcurrentToken.type !== \"EOF\"\n\t\t\t) {\n\t\t\t\tvar match = tokens.shift();\n\t\t\t\tconsumed.push(match);\n\t\t\t\ttokenList.push(currentToken);\n\t\t\t\tcurrentToken = token(0, true);\n\t\t\t}\n\t\t\tconsumeWhitespace(); // consume any whitespace\n\t\t\treturn tokenList;\n\t\t}\n\n\t\t/**\n\t\t * @returns {string}\n\t\t */\n\t\tfunction lastWhitespace() {\n\t\t\tif (consumed[consumed.length - 1] && consumed[consumed.length - 1].type === \"WHITESPACE\") {\n\t\t\t\treturn consumed[consumed.length - 1].value;\n\t\t\t} else {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\n\t\tfunction consumeUntilWhitespace() {\n\t\t\treturn consumeUntil(null, \"WHITESPACE\");\n\t\t}\n\n\t\t/**\n\t\t * @returns {boolean}\n\t\t */\n\t\tfunction hasMore() {\n\t\t\treturn tokens.length > 0;\n\t\t}\n\n\t\t/**\n\t\t * @param {number} n\n\t\t * @param {boolean} [dontIgnoreWhitespace]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction token(n, dontIgnoreWhitespace) {\n\t\t\tvar /**@type {Token}*/ token;\n\t\t\tvar i = 0;\n\t\t\tdo {\n\t\t\t\tif (!dontIgnoreWhitespace) {\n\t\t\t\t\twhile (tokens[i] && tokens[i].type === \"WHITESPACE\") {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttoken = tokens[i];\n\t\t\t\tn--;\n\t\t\t\ti++;\n\t\t\t} while (n > -1);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"EOF\",\n\t\t\t\t\tvalue: \"<<<EOF>>>\",\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction currentToken() {\n\t\t\treturn token(0);\n\t\t}\n\n\t\t/**\n\t\t * @returns {Token | null}\n\t\t */\n\t\tfunction lastMatch() {\n\t\t\treturn _lastConsumed;\n\t\t}\n\n\t\t/**\n\t\t * @returns {string}\n\t\t */\n\t\tfunction sourceFor() {\n\t\t\treturn source.substring(this.startToken.start, this.endToken.end);\n\t\t}\n\n\t\t/**\n\t\t * @returns {string}\n\t\t */\n\t\tfunction lineFor() {\n\t\t\treturn source.split(\"\\n\")[this.startToken.line - 1];\n\t\t}\n\n\t\tvar follows = [];\n\n\t\tfunction pushFollow(str) {\n\t\t\tfollows.push(str);\n\t\t}\n\n\t\tfunction popFollow() {\n\t\t\tfollows.pop();\n\t\t}\n\n\t\tfunction clearFollows() {\n\t\t\tvar tmp = follows;\n\t\t\tfollows = [];\n\t\t\treturn tmp;\n\t\t}\n\n\t\tfunction restoreFollows(f) {\n\t\t\tfollows = f;\n\t\t}\n\n\t\t/** @type {TokensObject} */\n\t\treturn {\n\t\t\tpushFollow: pushFollow,\n\t\t\tpopFollow: popFollow,\n\t\t\tclearFollow: clearFollows,\n\t\t\trestoreFollow: restoreFollows,\n\t\t\tmatchAnyToken: matchAnyToken,\n\t\t\tmatchAnyOpToken: matchAnyOpToken,\n\t\t\tmatchOpToken: matchOpToken,\n\t\t\trequireOpToken: requireOpToken,\n\t\t\tmatchTokenType: matchTokenType,\n\t\t\trequireTokenType: requireTokenType,\n\t\t\tconsumeToken: consumeToken,\n\t\t\tmatchToken: matchToken,\n\t\t\trequireToken: requireToken,\n\t\t\tlist: tokens,\n\t\t\tconsumed: consumed,\n\t\t\tsource: source,\n\t\t\thasMore: hasMore,\n\t\t\tcurrentToken: currentToken,\n\t\t\tlastMatch: lastMatch,\n\t\t\ttoken: token,\n\t\t\tconsumeUntil: consumeUntil,\n\t\t\tconsumeUntilWhitespace: consumeUntilWhitespace,\n\t\t\tlastWhitespace: lastWhitespace,\n\t\t\tsourceFor: sourceFor,\n\t\t\tlineFor: lineFor,\n\t\t};\n\t}\n\n\t/**\n\t * @param {Token[]} tokens\n\t * @returns {boolean}\n\t */\n\tfunction isValidSingleQuoteStringStart(tokens) {\n\t\tif (tokens.length > 0) {\n\t\t\tvar previousToken = tokens[tokens.length - 1];\n\t\t\tif (\n\t\t\t\tpreviousToken.type === \"IDENTIFIER\" ||\n\t\t\t\tpreviousToken.type === \"CLASS_REF\" ||\n\t\t\t\tpreviousToken.type === \"ID_REF\"\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (previousToken.op && (previousToken.value === \">\" || previousToken.value === \")\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {string} string\n\t * @param {boolean} [template]\n\t * @returns {TokensObject}\n\t */\n\tfunction tokenize(string, template) {\n\t\tvar tokens = /** @type {Token[]}*/ [];\n\t\tvar source = string;\n\t\tvar position = 0;\n\t\tvar column = 0;\n\t\tvar line = 1;\n\t\tvar lastToken = \"<START>\";\n\t\tvar templateBraceCount = 0;\n\n\t\tfunction inTemplate() {\n\t\t\treturn template && templateBraceCount === 0;\n\t\t}\n\n\t\twhile (position < source.length) {\n\t\t\tif (currentChar() === \"-\" && nextChar() === \"-\" && (isWhitespace(charAfterThat()) || charAfterThat() === \"\")) {\n\t\t\t\tconsumeComment();\n\t\t\t} else {\n\t\t\t\tif (isWhitespace(currentChar())) {\n\t\t\t\t\ttokens.push(consumeWhitespace());\n\t\t\t\t} else if (\n\t\t\t\t\t!possiblePrecedingSymbol() &&\n\t\t\t\t\tcurrentChar() === \".\" &&\n\t\t\t\t\t(isAlpha(nextChar()) || nextChar() === \"{\")\n\t\t\t\t) {\n\t\t\t\t\ttokens.push(consumeClassReference());\n\t\t\t\t} else if (\n\t\t\t\t\t!possiblePrecedingSymbol() &&\n\t\t\t\t\tcurrentChar() === \"#\" &&\n\t\t\t\t\t(isAlpha(nextChar()) || nextChar() === \"{\")\n\t\t\t\t) {\n\t\t\t\t\ttokens.push(consumeIdReference());\n\t\t\t\t} else if (currentChar() === \"[\" && nextChar() === \"@\") {\n\t\t\t\t\ttokens.push(consumeAttributeReference());\n\t\t\t\t} else if (currentChar() === \"@\") {\n\t\t\t\t\ttokens.push(consumeShortAttributeReference());\n\t\t\t\t} else if (isAlpha(currentChar()) || (!inTemplate() && isIdentifierChar(currentChar()))) {\n\t\t\t\t\ttokens.push(consumeIdentifier());\n\t\t\t\t} else if (isNumeric(currentChar())) {\n\t\t\t\t\ttokens.push(consumeNumber());\n\t\t\t\t} else if (!inTemplate() && (currentChar() === '\"' || currentChar() === \"`\")) {\n\t\t\t\t\ttokens.push(consumeString());\n\t\t\t\t} else if (!inTemplate() && currentChar() === \"'\") {\n\t\t\t\t\tif (isValidSingleQuoteStringStart(tokens)) {\n\t\t\t\t\t\ttokens.push(consumeString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttokens.push(consumeOp());\n\t\t\t\t\t}\n\t\t\t\t} else if (OP_TABLE[currentChar()]) {\n\t\t\t\t\tif (lastToken === \"$\" && currentChar() === \"{\") {\n\t\t\t\t\t\ttemplateBraceCount++;\n\t\t\t\t\t}\n\t\t\t\t\tif (currentChar() === \"}\") {\n\t\t\t\t\t\ttemplateBraceCount--;\n\t\t\t\t\t}\n\t\t\t\t\ttokens.push(consumeOp());\n\t\t\t\t} else if (inTemplate() || isReservedChar(currentChar())) {\n\t\t\t\t\ttokens.push(makeToken(\"RESERVED\", consumeChar()));\n\t\t\t\t} else {\n\t\t\t\t\tif (position < source.length) {\n\t\t\t\t\t\tthrow Error(\"Unknown token: \" + currentChar() + \" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn makeTokensObject(tokens, [], source);\n\n\t\t/**\n\t\t * @param {string} [type]\n\t\t * @param {string} [value]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction makeOpToken(type, value) {\n\t\t\tvar token = makeToken(type, value);\n\t\t\ttoken.op = true;\n\t\t\treturn token;\n\t\t}\n\n\t\t/**\n\t\t * @param {string} [type]\n\t\t * @param {string} [value]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction makeToken(type, value) {\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\tvalue: value,\n\t\t\t\tstart: position,\n\t\t\t\tend: position + 1,\n\t\t\t\tcolumn: column,\n\t\t\t\tline: line,\n\t\t\t};\n\t\t}\n\n\t\tfunction consumeComment() {\n\t\t\twhile (currentChar() && !isNewline(currentChar())) {\n\t\t\t\tconsumeChar();\n\t\t\t}\n\t\t\tconsumeChar();\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeClassReference() {\n\t\t\tvar classRef = makeToken(\"CLASS_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\tif (currentChar() === \"{\") {\n\t\t\t\tclassRef.template = true;\n\t\t\t\tvalue += consumeChar();\n\t\t\t\twhile (currentChar() && currentChar() !== \"}\") {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t\tif (currentChar() !== \"}\") {\n\t\t\t\t\tthrow Error(\"Unterminated class reference\");\n\t\t\t\t} else {\n\t\t\t\t\tvalue += consumeChar(); // consume final curly\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (isValidCSSClassChar(currentChar())) {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t}\n\t\t\tclassRef.value = value;\n\t\t\tclassRef.end = position;\n\t\t\treturn classRef;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeAttributeReference() {\n\t\t\tvar attributeRef = makeToken(\"ATTRIBUTE_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (position < source.length && currentChar() !== \"]\") {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tif (currentChar() === \"]\") {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tattributeRef.value = value;\n\t\t\tattributeRef.end = position;\n\t\t\treturn attributeRef;\n\t\t}\n\n\t\tfunction consumeShortAttributeReference() {\n\t\t\tvar attributeRef = makeToken(\"ATTRIBUTE_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (isValidCSSIDChar(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tattributeRef.value = value;\n\t\t\tattributeRef.end = position;\n\t\t\treturn attributeRef;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeIdReference() {\n\t\t\tvar idRef = makeToken(\"ID_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\tif (currentChar() === \"{\") {\n\t\t\t\tidRef.template = true;\n\t\t\t\tvalue += consumeChar();\n\t\t\t\twhile (currentChar() && currentChar() !== \"}\") {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t\tif (currentChar() !== \"}\") {\n\t\t\t\t\tthrow Error(\"Unterminated id reference\");\n\t\t\t\t} else {\n\t\t\t\t\tconsumeChar(); // consume final quote\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (isValidCSSIDChar(currentChar())) {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t}\n\t\t\tidRef.value = value;\n\t\t\tidRef.end = position;\n\t\t\treturn idRef;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeIdentifier() {\n\t\t\tvar identifier = makeToken(\"IDENTIFIER\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (isAlpha(currentChar()) || isIdentifierChar(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tidentifier.value = value;\n\t\t\tidentifier.end = position;\n\t\t\treturn identifier;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeNumber() {\n\t\t\tvar number = makeToken(\"NUMBER\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (isNumeric(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tif (currentChar() === \".\" && isNumeric(nextChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\twhile (isNumeric(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tnumber.value = value;\n\t\t\tnumber.end = position;\n\t\t\treturn number;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeOp() {\n\t\t\tvar op = makeOpToken();\n\t\t\tvar value = consumeChar(); // consume leading char\n\t\t\twhile (currentChar() && OP_TABLE[value + currentChar()]) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\top.type = OP_TABLE[value];\n\t\t\top.value = value;\n\t\t\top.end = position;\n\t\t\treturn op;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeString() {\n\t\t\tvar string = makeToken(\"STRING\");\n\t\t\tvar startChar = consumeChar(); // consume leading quote\n\t\t\tvar value = \"\";\n\t\t\twhile (currentChar() && currentChar() !== startChar) {\n\t\t\t\tif (currentChar() === \"\\\\\") {\n\t\t\t\t\tconsumeChar(); // consume escape char and move on\n\t\t\t\t}\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tif (currentChar() !== startChar) {\n\t\t\t\tthrow Error(\"Unterminated string at \" + positionString(string));\n\t\t\t} else {\n\t\t\t\tconsumeChar(); // consume final quote\n\t\t\t}\n\t\t\tstring.value = value;\n\t\t\tstring.end = position;\n\t\t\tstring.template = startChar === \"`\";\n\t\t\treturn string;\n\t\t}\n\n\t\t/**\n\t\t * @returns string\n\t\t */\n\t\tfunction currentChar() {\n\t\t\treturn source.charAt(position);\n\t\t}\n\n\t\t/**\n\t\t * @returns string\n\t\t */\n\t\tfunction nextChar() {\n\t\t\treturn source.charAt(position + 1);\n\t\t}\n\n\t\tfunction charAfterThat() {\n\t\t\treturn source.charAt(position + 2);\n\t\t}\n\n\t\t/**\n\t\t * @returns string\n\t\t */\n\t\tfunction consumeChar() {\n\t\t\tlastToken = currentChar();\n\t\t\tposition++;\n\t\t\tcolumn++;\n\t\t\treturn lastToken;\n\t\t}\n\n\t\t/**\n\t\t * @returns boolean\n\t\t */\n\t\tfunction possiblePrecedingSymbol() {\n\t\t\treturn (\n\t\t\t\tisAlpha(lastToken) ||\n\t\t\t\tisNumeric(lastToken) ||\n\t\t\t\tlastToken === \")\" ||\n\t\t\t\tlastToken === \"}\" ||\n\t\t\t\tlastToken === \"]\"\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeWhitespace() {\n\t\t\tvar whitespace = makeToken(\"WHITESPACE\");\n\t\t\tvar value = \"\";\n\t\t\twhile (currentChar() && isWhitespace(currentChar())) {\n\t\t\t\tif (isNewline(currentChar())) {\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\tline++;\n\t\t\t\t}\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\twhitespace.value = value;\n\t\t\twhitespace.end = position;\n\t\t\treturn whitespace;\n\t\t}\n\t}\n\n\treturn {\n\t\ttokenize: tokenize,\n\t\tmakeTokensObject: makeTokensObject,\n\t};\n})();\n\n//====================================================================\n// Parser\n//====================================================================\n\n/** @type ParserObject */\nvar _parser = (function () {\n\t/** @type {Object<string,GrammarDefinition>} */\n\tvar GRAMMAR = {};\n\n\t/** @type {Object<string,GrammarDefinition>} */\n\tvar COMMANDS = {};\n\n\t/** @type {Object<string,GrammarDefinition>} */\n\tvar FEATURES = {};\n\n\tvar LEAF_EXPRESSIONS = [];\n\tvar INDIRECT_EXPRESSIONS = [];\n\n\t/**\n\t * @param {*} parseElement\n\t * @param {*} start\n\t * @param {TokensObject} tokens\n\t */\n\tfunction initElt(parseElement, start, tokens) {\n\t\tparseElement.startToken = start;\n\t\tparseElement.sourceFor = tokens.sourceFor;\n\t\tparseElement.lineFor = tokens.lineFor;\n\t\tparseElement.programSource = tokens.source;\n\t}\n\n\t/**\n\t * @param {string} type\n\t * @param {TokensObject} tokens\n\t * @param {GrammarElement?} root\n\t * @returns GrammarElement\n\t */\n\tfunction parseElement(type, tokens, root = undefined) {\n\t\tvar elementDefinition = GRAMMAR[type];\n\t\tif (elementDefinition) {\n\t\t\tvar start = tokens.currentToken();\n\t\t\tvar parseElement = elementDefinition(_parser, _runtime, tokens, root);\n\t\t\tif (parseElement) {\n\t\t\t\tinitElt(parseElement, start, tokens);\n\t\t\t\tparseElement.endToken = parseElement.endToken || tokens.lastMatch();\n\t\t\t\tvar root = parseElement.root;\n\t\t\t\twhile (root != null) {\n\t\t\t\t\tinitElt(root, start, tokens);\n\t\t\t\t\troot = root.root;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn parseElement;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} type\n\t * @param {TokensObject} tokens\n\t * @param {string} [message]\n\t * @param {*} [root]\n\t * @returns {GrammarElement}\n\t */\n\tfunction requireElement(type, tokens, message, root) {\n\t\tvar result = parseElement(type, tokens, root);\n\t\tif (!result) raiseParseError(tokens, message || \"Expected \" + type);\n\t\t// @ts-ignore\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {string[]} types\n\t * @param {TokensObject} tokens\n\t * @returns {GrammarElement}\n\t */\n\tfunction parseAnyOf(types, tokens) {\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tvar type = types[i];\n\t\t\tvar expression = parseElement(type, tokens);\n\t\t\tif (expression) {\n\t\t\t\treturn expression;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addGrammarElement(name, definition) {\n\t\tGRAMMAR[name] = definition;\n\t}\n\n\t/**\n\t * @param {string} keyword\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addCommand(keyword, definition) {\n\t\tvar commandGrammarType = keyword + \"Command\";\n\t\tvar commandDefinitionWrapper = function (parser, runtime, tokens) {\n\t\t\tconst commandElement = definition(parser, runtime, tokens);\n\t\t\tif (commandElement) {\n\t\t\t\tcommandElement.type = commandGrammarType;\n\t\t\t\tcommandElement.execute = function (context) {\n\t\t\t\t\tcontext.meta.command = commandElement;\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t};\n\t\t\t\treturn commandElement;\n\t\t\t}\n\t\t};\n\t\tGRAMMAR[commandGrammarType] = commandDefinitionWrapper;\n\t\tCOMMANDS[keyword] = commandDefinitionWrapper;\n\t}\n\n\t/**\n\t * @param {string} keyword\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addFeature(keyword, definition) {\n\t\tvar featureGrammarType = keyword + \"Feature\";\n\n\t\t/** @type {GrammarDefinition} */\n\t\tvar featureDefinitionWrapper = function (parser, runtime, tokens) {\n\t\t\tvar featureElement = definition(parser, runtime, tokens);\n\t\t\tif (featureElement) {\n\t\t\t\tfeatureElement.keyword = keyword;\n\t\t\t\tfeatureElement.type = featureGrammarType;\n\t\t\t\treturn featureElement;\n\t\t\t}\n\t\t};\n\t\tGRAMMAR[featureGrammarType] = featureDefinitionWrapper;\n\t\tFEATURES[keyword] = featureDefinitionWrapper;\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addLeafExpression(name, definition) {\n\t\tLEAF_EXPRESSIONS.push(name);\n\t\taddGrammarElement(name, definition);\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addIndirectExpression(name, definition) {\n\t\tINDIRECT_EXPRESSIONS.push(name);\n\t\taddGrammarElement(name, definition);\n\t}\n\n\t/* ============================================================================================ */\n\t/* Core hyperscript Grammar Elements                                                            */\n\t/* ============================================================================================ */\n\taddGrammarElement(\"feature\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tvar featureElement = parser.requireElement(\"feature\", tokens);\n\t\t\ttokens.requireOpToken(\")\");\n\t\t\treturn featureElement;\n\t\t}\n\n\t\tvar featureDefinition = FEATURES[tokens.currentToken().value];\n\t\tif (featureDefinition) {\n\t\t\treturn featureDefinition(parser, runtime, tokens);\n\t\t}\n\t});\n\n\taddGrammarElement(\"command\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tconst commandElement = parser.requireElement(\"command\", tokens);\n\t\t\ttokens.requireOpToken(\")\");\n\t\t\treturn commandElement;\n\t\t}\n\n\t\tvar commandDefinition = COMMANDS[tokens.currentToken().value];\n\t\tlet commandElement;\n\t\tif (commandDefinition) {\n\t\t\tcommandElement = commandDefinition(parser, runtime, tokens);\n\t\t} else if (tokens.currentToken().type === \"IDENTIFIER\" && tokens.token(1).value === \"(\") {\n\t\t\tcommandElement = parser.requireElement(\"pseudoCommand\", tokens);\n\t\t}\n\t\tif (commandElement) {\n\t\t\treturn parser.parseElement(\"indirectStatement\", tokens, commandElement);\n\t\t}\n\n\t\treturn commandElement;\n\t});\n\n\taddGrammarElement(\"commandList\", function (parser, runtime, tokens) {\n\t\tvar cmd = parser.parseElement(\"command\", tokens);\n\t\tif (cmd) {\n\t\t\ttokens.matchToken(\"then\");\n\t\t\tconst next = parser.parseElement(\"commandList\", tokens);\n\t\t\tif (next) cmd.next = next;\n\t\t\treturn cmd;\n\t\t}\n\t});\n\n\taddGrammarElement(\"leaf\", function (parser, runtime, tokens) {\n\t\tvar result = parseAnyOf(LEAF_EXPRESSIONS, tokens);\n\t\t// symbol is last so it doesn't consume any constants\n\t\tif (result == null) {\n\t\t\treturn parseElement(\"symbol\", tokens);\n\t\t}\n\n\t\treturn result;\n\t});\n\n\taddGrammarElement(\"indirectExpression\", function (parser, runtime, tokens, root) {\n\t\tfor (var i = 0; i < INDIRECT_EXPRESSIONS.length; i++) {\n\t\t\tvar indirect = INDIRECT_EXPRESSIONS[i];\n\t\t\troot.endToken = tokens.lastMatch();\n\t\t\tvar result = parser.parseElement(indirect, tokens, root);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn root;\n\t});\n\n\taddGrammarElement(\"indirectStatement\", function (parser, runtime, tokens, root) {\n\t\tif (tokens.matchToken(\"unless\")) {\n\t\t\troot.endToken = tokens.lastMatch();\n\t\t\tvar conditional = parser.requireElement(\"expression\", tokens);\n\t\t\tvar unless = {\n\t\t\t\ttype: \"unlessStatementModifier\",\n\t\t\t\targs: [conditional],\n\t\t\t\top: function (context, conditional) {\n\t\t\t\t\tif (conditional) {\n\t\t\t\t\t\treturn this.next;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn root;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\troot.parent = unless;\n\t\t\treturn unless;\n\t\t}\n\t\treturn root;\n\t});\n\n\taddGrammarElement(\"primaryExpression\", function (parser, runtime, tokens) {\n\t\tvar leaf = parser.parseElement(\"leaf\", tokens);\n\t\tif (leaf) {\n\t\t\treturn parser.parseElement(\"indirectExpression\", tokens, leaf);\n\t\t}\n\t\tparser.raiseParseError(tokens, \"Unexpected value: \" + tokens.currentToken().value);\n\t});\n\n\t/* ============================================================================================ */\n\t/* END Core hyperscript Grammar Elements                                                        */\n\n\t/* ============================================================================================ */\n\n\t/**\n\t *\n\t * @param {TokensObject} tokens\n\t * @returns string\n\t */\n\tfunction createParserContext(tokens) {\n\t\tvar currentToken = tokens.currentToken();\n\t\tvar source = tokens.source;\n\t\tvar lines = source.split(\"\\n\");\n\t\tvar line = currentToken && currentToken.line ? currentToken.line - 1 : lines.length - 1;\n\t\tvar contextLine = lines[line];\n\t\tvar offset = currentToken && currentToken.line ? currentToken.column : contextLine.length - 1;\n\t\treturn contextLine + \"\\n\" + \" \".repeat(offset) + \"^^\\n\\n\";\n\t}\n\n\t/**\n\t * @param {TokensObject} tokens\n\t * @param {string} [message]\n\t */\n\tfunction raiseParseError(tokens, message) {\n\t\tmessage =\n\t\t\t(message || \"Unexpected Token : \" + tokens.currentToken().value) + \"\\n\\n\" + createParserContext(tokens);\n\t\tvar error = new Error(message);\n\t\terror[\"tokens\"] = tokens;\n\t\tthrow error;\n\t}\n\n\t/**\n\t * @param {TokensObject} tokens\n\t * @returns {GrammarElement}\n\t */\n\tfunction parseHyperScript(tokens) {\n\t\tvar result = parseElement(\"hyperscript\", tokens);\n\t\tif (tokens.hasMore()) raiseParseError(tokens);\n\t\tif (result) return result;\n\t}\n\n\t/**\n\t * @param {GrammarElement} elt\n\t * @param {GrammarElement} parent\n\t */\n\tfunction setParent(elt, parent) {\n\t\tif (elt) {\n\t\t\telt.parent = parent;\n\t\t\tsetParent(elt.next, parent);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Token} token\n\t * @returns {GrammarDefinition}\n\t */\n\tfunction commandStart(token) {\n\t\treturn COMMANDS[token.value];\n\t}\n\n\t/**\n\t * @param {Token} token\n\t * @returns {GrammarDefinition}\n\t */\n\tfunction featureStart(token) {\n\t\treturn FEATURES[token.value];\n\t}\n\n\t/**\n\t * @param {Token} token\n\t * @returns {boolean}\n\t */\n\tfunction commandBoundary(token) {\n\t\tif (\n\t\t\ttoken.value == \"end\" ||\n\t\t\ttoken.value == \"then\" ||\n\t\t\ttoken.value == \"else\" ||\n\t\t\ttoken.value == \")\" ||\n\t\t\tcommandStart(token) ||\n\t\t\tfeatureStart(token) ||\n\t\t\ttoken.type == \"EOF\"\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {TokensObject} tokens\n\t * @returns {(string | GrammarElement)[]}\n\t */\n\tfunction parseStringTemplate(tokens) {\n\t\t/** @type {(string | GrammarElement)[]} */\n\t\tvar returnArr = [\"\"];\n\t\tdo {\n\t\t\treturnArr.push(tokens.lastWhitespace());\n\t\t\tif (tokens.currentToken().value === \"$\") {\n\t\t\t\ttokens.consumeToken();\n\t\t\t\tvar startingBrace = tokens.matchOpToken(\"{\");\n\t\t\t\treturnArr.push(requireElement(\"expression\", tokens));\n\t\t\t\tif (startingBrace) {\n\t\t\t\t\ttokens.requireOpToken(\"}\");\n\t\t\t\t}\n\t\t\t\treturnArr.push(\"\");\n\t\t\t} else if (tokens.currentToken().value === \"\\\\\") {\n\t\t\t\ttokens.consumeToken(); // skip next\n\t\t\t\ttokens.consumeToken();\n\t\t\t} else {\n\t\t\t\tvar token = tokens.consumeToken();\n\t\t\t\treturnArr[returnArr.length - 1] += token ? token.value : \"\";\n\t\t\t}\n\t\t} while (tokens.hasMore());\n\t\treturnArr.push(tokens.lastWhitespace());\n\t\treturn returnArr;\n\t}\n\n\t// parser API\n\treturn {\n\t\tsetParent: setParent,\n\t\trequireElement: requireElement,\n\t\tparseElement: parseElement,\n\t\tfeatureStart: featureStart,\n\t\tcommandStart: commandStart,\n\t\tcommandBoundary: commandBoundary,\n\t\tparseAnyOf: parseAnyOf,\n\t\tparseHyperScript: parseHyperScript,\n\t\traiseParseError: raiseParseError,\n\t\taddGrammarElement: addGrammarElement,\n\t\taddCommand: addCommand,\n\t\taddFeature: addFeature,\n\t\taddLeafExpression: addLeafExpression,\n\t\taddIndirectExpression: addIndirectExpression,\n\t\tparseStringTemplate: parseStringTemplate,\n\t};\n})();\n\n//====================================================================\n// Runtime\n//====================================================================\n\nvar CONVERSIONS = {\n\tdynamicResolvers: /** @type DynamicConversionFunction[] */ [],\n\tString: function (val) {\n\t\tif (val.toString) {\n\t\t\treturn val.toString();\n\t\t} else {\n\t\t\treturn \"\" + val;\n\t\t}\n\t},\n\tInt: function (val) {\n\t\treturn parseInt(val);\n\t},\n\tFloat: function (val) {\n\t\treturn parseFloat(val);\n\t},\n\tNumber: function (val) {\n\t\tconsole.log(val);\n\t\treturn Number(val);\n\t},\n\tDate: function (val) {\n\t\treturn new Date(val);\n\t},\n\tArray: function (val) {\n\t\treturn Array.from(val);\n\t},\n\tJSON: function (val) {\n\t\treturn JSON.stringify(val);\n\t},\n\tObject: function (val) {\n\t\tif (val instanceof String) {\n\t\t\tval = val.toString();\n\t\t}\n\t\tif (typeof val === \"string\") {\n\t\t\treturn JSON.parse(val);\n\t\t} else {\n\t\t\treturn mergeObjects({}, val);\n\t\t}\n\t},\n};\n\n/********************************************\n * RUNTIME OBJECT\n ********************************************/\n\n/** @type {RuntimeObject} */\nvar _runtime = (function () {\n\t/**\n\t * @param {HTMLElement} elt\n\t * @param {string} selector\n\t * @returns boolean\n\t */\n\tfunction matchesSelector(elt, selector) {\n\t\t// noinspection JSUnresolvedVariable\n\t\tvar matchesFunction =\n\t\t\t// @ts-ignore\n\t\t\telt.matches || elt.matchesSelector || elt.msMatchesSelector || elt.mozMatchesSelector || elt.webkitMatchesSelector || elt.oMatchesSelector;\n\t\treturn matchesFunction && matchesFunction.call(elt, selector);\n\t}\n\n\t/**\n\t * @param {string} eventName\n\t * @param {Object} [detail]\n\t * @returns {Event}\n\t */\n\tfunction makeEvent(eventName, detail) {\n\t\tvar evt;\n\t\tif (globalScope.Event && typeof globalScope.Event === \"function\") {\n\t\t\tevt = new Event(eventName, {\n\t\t\t\tbubbles: true,\n\t\t\t\tcancelable: true,\n\t\t\t});\n\t\t\tevt['detail'] = detail;\n\t\t} else {\n\t\t\tevt = document.createEvent(\"CustomEvent\");\n\t\t\tevt.initCustomEvent(eventName, true, true, detail);\n\t\t}\n\t\treturn evt;\n\t}\n\n\t/**\n\t * @param {Element} elt\n\t * @param {string} eventName\n\t * @param {Object} [detail]\n\t * @returns {boolean}\n\t */\n\tfunction triggerEvent(elt, eventName, detail) {\n\t\tdetail = detail || {};\n\t\tdetail[\"sentBy\"] = elt;\n\t\tvar event = makeEvent(eventName, detail);\n\t\tvar eventResult = elt.dispatchEvent(event);\n\t\treturn eventResult;\n\t}\n\n\t/**\n\t * isArrayLike returns `true` if the provided value is an array or\n\t * a NodeList (which is close enough to being an array for our purposes).\n\t *\n\t * @param {any} value\n\t * @returns {value is Array | NodeList}\n\t */\n\tfunction isArrayLike(value) {\n\t\treturn Array.isArray(value) || (typeof NodeList !== 'undefined' && value instanceof NodeList);\n\t}\n\n\t/**\n\t * isIterable returns `true` if the provided value supports the\n\t * iterator protocol.\n\t *\n\t * @param {any} value\n\t * @returns {value is Iterable}\n\t */\n\tfunction isIterable(value) {\n\t\treturn typeof value === 'object'\n\t\t\t&& Symbol.iterator in value\n\t\t\t&& typeof value[Symbol.iterator] === 'function';\n\t}\n\n\t/**\n\t * shouldAutoIterate returns `true` if the provided value\n\t * should be implicitly iterated over when accessing properties,\n\t * and as the target of some commands.\n\t *\n\t * Currently, this is when the value is an {ElementCollection}\n\t * or {isArrayLike} returns true.\n\t *\n\t * @param {any} value\n\t * @returns {value is any[] | NodeList | ElementCollection}\n\t */\n\tfunction shouldAutoIterate(value) {\n\t\treturn value instanceof ElementCollection || isArrayLike(value);\n\t}\n\n\t/**\n\t * forEach executes the provided `func` on every item in the `value` array.\n\t * if `value` is a single item (and not an array) then `func` is simply called\n\t * once.  If `value` is null, then no further actions are taken.\n\t *\n\t * @template T\n\t * @param {T | Iterable<T>} value\n\t * @param {(item: T) => void} func\n\t */\n\tfunction forEach(value, func) {\n\t\tif (value == null) {\n\t\t\t// do nothing\n\t\t} else if (isIterable(value)) {\n\t\t\tfor (const nth of value) {\n\t\t\t\tfunc(nth);\n\t\t\t}\n\t\t} else if (isArrayLike(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tfunc(value[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfunc(value);\n\t\t}\n\t}\n\n\t/**\n\t * implicitLoop executes the provided `func` on:\n\t * - every item of {value}, if {value} should be auto-iterated\n\t *   (see {shouldAutoIterate})\n\t * - {value} otherwise\n\t *\n\t * @template T\n\t * @param {NodeList | T | T[]} value\n\t * @param {(item:Node | T) => void} func\n\t */\n\tfunction implicitLoop(value, func) {\n\t\tif (shouldAutoIterate(value)) {\n\t\t\tfor (const x of value) func(x);\n\t\t} else {\n\t\t\tfunc(value);\n\t\t}\n\t}\n\n\tvar ARRAY_SENTINEL = { array_sentinel: true };\n\n\tfunction linearize(args) {\n\t\tvar arr = [];\n\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\tvar arg = args[i];\n\t\t\tif (Array.isArray(arg)) {\n\t\t\t\tarr.push(ARRAY_SENTINEL);\n\t\t\t\tfor (var j = 0; j < arg.length; j++) {\n\t\t\t\t\tarr.push(arg[j]);\n\t\t\t\t}\n\t\t\t\tarr.push(ARRAY_SENTINEL);\n\t\t\t} else {\n\t\t\t\tarr.push(arg);\n\t\t\t}\n\t\t}\n\t\treturn arr;\n\t}\n\n\tfunction delinearize(values) {\n\t\tvar arr = [];\n\t\tfor (var i = 0; i < values.length; i++) {\n\t\t\tvar value = values[i];\n\t\t\tif (value === ARRAY_SENTINEL) {\n\t\t\t\tvalue = values[++i];\n\t\t\t\tvar valueArray = [];\n\t\t\t\tarr.push(valueArray);\n\t\t\t\twhile (value !== ARRAY_SENTINEL) {\n\t\t\t\t\tvalueArray.push(value);\n\t\t\t\t\tvalue = values[++i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarr.push(value);\n\t\t\t}\n\t\t}\n\t\treturn arr;\n\t}\n\n\tfunction unwrapAsyncs(values) {\n\t\tfor (var i = 0; i < values.length; i++) {\n\t\t\tvar value = values[i];\n\t\t\tif (value.asyncWrapper) {\n\t\t\t\tvalues[i] = value.value;\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tfor (var j = 0; j < value.length; j++) {\n\t\t\t\t\tvar valueElement = value[j];\n\t\t\t\t\tif (valueElement.asyncWrapper) {\n\t\t\t\t\t\tvalue[j] = valueElement.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar HALT = {};\n\n\t/**\n\t * @param {GrammarElement} command\n\t * @param {Context} ctx\n\t */\n\tfunction unifiedExec(command, ctx) {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tvar next = unifiedEval(command, ctx);\n\t\t\t} catch (e) {\n\t\t\t\t_runtime.registerHyperTrace(ctx, e);\n\t\t\t\tif (ctx.meta.errorHandler && !ctx.meta.handlingError) {\n\t\t\t\t\tctx.meta.handlingError = true;\n\t\t\t\t\tctx[ctx.meta.errorSymmbol] = e;\n\t\t\t\t\tcommand = ctx.meta.errorHandler;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ctx.meta.reject) {\n\t\t\t\t\tctx.meta.reject(e);\n\t\t\t\t\tnext = HALT;\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (next == null) {\n\t\t\t\tconsole.error(command, \" did not return a next element to execute! context: \", ctx);\n\t\t\t\treturn;\n\t\t\t} else if (next.then) {\n\t\t\t\tnext.then(function (resolvedNext) {\n\t\t\t\t\tunifiedExec(resolvedNext, ctx);\n\t\t\t\t}).catch(function (reason) {\n\t\t\t\t\t_runtime.registerHyperTrace(ctx, reason);\n\t\t\t\t\tif (ctx.meta.errorHandler && !ctx.meta.handlingError) {\n\t\t\t\t\t\tctx.meta.handlingError = true;\n\t\t\t\t\t\tctx[ctx.meta.errorSymmbol] = reason;\n\t\t\t\t\t\tunifiedExec(ctx.meta.errorHandler, ctx);\n\t\t\t\t\t} else if (ctx.meta.reject) {\n\t\t\t\t\t\tctx.meta.reject(reason);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t} else if (next === HALT) {\n\t\t\t\t// done\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tcommand = next; // move to the next command\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* @param {*} parseElement\n\t* @param {Context} ctx\n\t* @returns {*}\n\t*/\n\tfunction unifiedEval(parseElement, ctx) {\n\t\t/** @type any[] */\n\t\tvar args = [ctx];\n\t\tvar async = false;\n\t\tvar wrappedAsyncs = false;\n\n\t\tif (parseElement.args) {\n\t\t\tfor (var i = 0; i < parseElement.args.length; i++) {\n\t\t\t\tvar argument = parseElement.args[i];\n\t\t\t\tif (argument == null) {\n\t\t\t\t\targs.push(null);\n\t\t\t\t} else if (Array.isArray(argument)) {\n\t\t\t\t\tvar arr = [];\n\t\t\t\t\tfor (var j = 0; j < argument.length; j++) {\n\t\t\t\t\t\tvar element = argument[j];\n\t\t\t\t\t\tvar value = element ? element.evaluate(ctx) : null; // OK\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\tif (value.then) {\n\t\t\t\t\t\t\t\tasync = true;\n\t\t\t\t\t\t\t} else if (value.asyncWrapper) {\n\t\t\t\t\t\t\t\twrappedAsyncs = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tarr.push(value);\n\t\t\t\t\t}\n\t\t\t\t\targs.push(arr);\n\t\t\t\t} else if (argument.evaluate) {\n\t\t\t\t\tvar value = argument.evaluate(ctx); // OK\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tif (value.then) {\n\t\t\t\t\t\t\tasync = true;\n\t\t\t\t\t\t} else if (value.asyncWrapper) {\n\t\t\t\t\t\t\twrappedAsyncs = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\targs.push(value);\n\t\t\t\t} else {\n\t\t\t\t\targs.push(argument);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (async) {\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tvar linearized = linearize(args);\n\t\t\t\tPromise.all(linearized)\n\t\t\t\t\t.then(function (values) {\n\t\t\t\t\t\tvalues = delinearize(values);\n\t\t\t\t\t\tif (wrappedAsyncs) {\n\t\t\t\t\t\t\tunwrapAsyncs(values);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar apply = parseElement.op.apply(parseElement, values);\n\t\t\t\t\t\t\tresolve(apply);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\treject(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch(function (reason) {\n\t\t\t\t\t\tif (ctx.meta.errorHandler && !ctx.meta.handlingError) {\n\t\t\t\t\t\t\tctx.meta.handlingError = true;\n\t\t\t\t\t\t\tctx[ctx.meta.errorSymmbol] = reason;\n\t\t\t\t\t\t\tunifiedExec(ctx.meta.errorHandler, ctx);\n\t\t\t\t\t\t} else if (ctx.meta.reject) {\n\t\t\t\t\t\t\tctx.meta.reject(reason);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// TODO: no meta context to reject with, trigger event?\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tif (wrappedAsyncs) {\n\t\t\t\tunwrapAsyncs(args);\n\t\t\t}\n\t\t\treturn parseElement.op.apply(parseElement, args);\n\t\t}\n\t}\n\n\tlet _scriptAttrs = null;\n\n\t/**\n\t* getAttributes returns the attribute name(s) to use when\n\t* locating hyperscript scripts in a DOM element.  If no value\n\t* has been configured, it defaults to _hyperscript.config.attributes\n\t* @returns string[]\n\t*/\n\tfunction getScriptAttributes() {\n\t\tif (_scriptAttrs == null) {\n\t\t\t_scriptAttrs = _hyperscript.config.attributes.replace(/ /g, \"\").split(\",\");\n\t\t}\n\t\treturn _scriptAttrs;\n\t}\n\n\t/**\n\t* @param {Element} elt\n\t* @returns {string | null}\n\t*/\n\tfunction getScript(elt) {\n\t\tfor (var i = 0; i < getScriptAttributes().length; i++) {\n\t\t\tvar scriptAttribute = getScriptAttributes()[i];\n\t\t\tif (elt.hasAttribute && elt.hasAttribute(scriptAttribute)) {\n\t\t\t\treturn elt.getAttribute(scriptAttribute);\n\t\t\t}\n\t\t}\n\t\tif (elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\") {\n\t\t\treturn elt.innerText;\n\t\t}\n\t\treturn null;\n\t}\n\n\tvar hyperscriptFeaturesMap = new WeakMap\n\n\t/**\n\t* @param {*} elt\n\t* @returns {Object}\n\t*/\n\tfunction getHyperscriptFeatures(elt) {\n\t\tvar hyperscriptFeatures = hyperscriptFeaturesMap.get(elt);\n\t\tif (typeof hyperscriptFeatures === 'undefined') {\n\t\t\thyperscriptFeaturesMap.set(elt, hyperscriptFeatures = {});\n\t\t}\n\t\treturn hyperscriptFeatures;\n\t}\n\n\t/**\n\t* @param {Object} owner\n\t* @param {Context} ctx\n\t*/\n\tfunction addFeatures(owner, ctx) {\n\t\tif (owner) {\n\t\t\tmergeObjects(ctx, getHyperscriptFeatures(owner));\n\t\t\taddFeatures(owner.parentElement, ctx);\n\t\t}\n\t}\n\n\t/**\n\t* @param {*} owner\n\t* @param {*} feature\n\t* @param {*} hyperscriptTarget\n\t* @param {*} event\n\t* @returns {Context}\n\t*/\n\tfunction makeContext(owner, feature, hyperscriptTarget, event) {\n\t\t/** @type {Context} */\n\t\tvar ctx = {\n\t\t\tmeta: {\n\t\t\t\tparser: _parser,\n\t\t\t\tlexer: _lexer,\n\t\t\t\truntime: _runtime,\n\t\t\t\towner: owner,\n\t\t\t\tfeature: feature,\n\t\t\t\titerators: {},\n\t\t\t},\n\t\t\tme: hyperscriptTarget,\n\t\t\tevent: event,\n\t\t\ttarget: event ? event.target : null,\n\t\t\tdetail: event ? event.detail : null,\n\t\t\tbody: \"document\" in globalScope ? document.body : null,\n\t\t};\n\t\tctx.meta.ctx = ctx;\n\t\taddFeatures(owner, ctx);\n\t\treturn ctx;\n\t}\n\n\t/**\n\t* @returns string\n\t*/\n\tfunction getScriptSelector() {\n\t\treturn getScriptAttributes()\n\t\t\t.map(function (attribute) {\n\t\t\t\treturn \"[\" + attribute + \"]\";\n\t\t\t})\n\t\t\t.join(\", \");\n\t}\n\n\t/**\n\t* @param {any} value\n\t* @param {string} type\n\t* @returns {any}\n\t*/\n\tfunction convertValue(value, type) {\n\t\tvar dynamicResolvers = CONVERSIONS.dynamicResolvers;\n\t\tfor (var i = 0; i < dynamicResolvers.length; i++) {\n\t\t\tvar dynamicResolver = dynamicResolvers[i];\n\t\t\tvar converted = dynamicResolver(type, value);\n\t\t\tif (converted !== undefined) {\n\t\t\t\treturn converted;\n\t\t\t}\n\t\t}\n\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tvar converter = CONVERSIONS[type];\n\t\tif (converter) {\n\t\t\treturn converter(value);\n\t\t}\n\n\t\tthrow \"Unknown conversion : \" + type;\n\t}\n\n\t// TODO: There do not seem to be any references to this function.\n\t// Is it still in use, or can it be removed?\n\tfunction isType(o, type) {\n\t\treturn Object.prototype.toString.call(o) === \"[object \" + type + \"]\";\n\t}\n\n\t/**\n\t* @param {string} src\n\t* @returns {GrammarElement}\n\t*/\n\tfunction parse(src) {\n\t\tvar tokens = _lexer.tokenize(src);\n\t\tif (_parser.commandStart(tokens.currentToken())) {\n\t\t\tvar commandList = _parser.requireElement(\"commandList\", tokens);\n\t\t\tvar last = commandList;\n\t\t\twhile (last.next) {\n\t\t\t\tlast = last.next;\n\t\t\t}\n\t\t\tlast.next = {\n\t\t\t\top: function () {\n\t\t\t\t\treturn HALT;\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn commandList;\n\t\t} else if (_parser.featureStart(tokens.currentToken())) {\n\t\t\tvar hyperscript = _parser.requireElement(\"hyperscript\", tokens);\n\t\t\treturn hyperscript;\n\t\t} else {\n\t\t\tvar expression = _parser.requireElement(\"expression\", tokens);\n\t\t\treturn expression;\n\t\t}\n\t}\n\n\tfunction evaluateNoPromise(elt, ctx) {\n\t\tlet result = elt.evaluate(ctx);\n\t\tif (result.next) {\n\t\t\tthrow new Error(elt.sourceFor() + \" returned a Promise in a context that they are not allowed.\");\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t* @param {string} src\n\t* @param {Context} [ctx]\n\t* @param {Object} [args]\n\t* @returns {any}\n\t*/\n\tfunction evaluate(src, ctx, args) {\n\t\tclass HyperscriptModule extends EventTarget {\n\t\t\tconstructor(mod) {\n\t\t\t\tsuper();\n\t\t\t\tthis.module = mod;\n\t\t\t}\n\t\t\ttoString() {\n\t\t\t\treturn this.module.id;\n\t\t\t}\n\t\t}\n\n\t\tvar body = 'document' in globalScope\n\t\t\t? globalScope.document.body\n\t\t\t: new HyperscriptModule(args && args.module);\n\t\tctx = mergeObjects(makeContext(body, null, body, null), ctx || {});\n\t\tvar element = parse(src);\n\t\tif (element.execute) {\n\t\t\telement.execute(ctx);\n\t\t\treturn ctx.result;\n\t\t} else if (element.apply) {\n\t\t\telement.apply(body, body, args);\n\t\t\treturn getHyperscriptFeatures(body);\n\t\t} else {\n\t\t\treturn element.evaluate(ctx);\n\t\t}\n\n\t\tfunction makeModule() {\n\t\t\treturn {}\n\t\t}\n\t}\n\n\t/**\n\t* @param {HTMLElement} elt\n\t*/\n\tfunction processNode(elt) {\n\t\tvar selector = _runtime.getScriptSelector();\n\t\tif (matchesSelector(elt, selector)) {\n\t\t\tinitElement(elt, elt);\n\t\t}\n\t\tif (elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\") {\n\t\t\tinitElement(elt, document.body);\n\t\t}\n\t\tif (elt.querySelectorAll) {\n\t\t\tforEach(elt.querySelectorAll(selector + \", [type='text/hyperscript']\"), function (elt) {\n\t\t\t\tinitElement(elt, elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\" ? document.body : elt);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t* @param {Element} elt\n\t* @param {Element} [target]\n\t*/\n\tfunction initElement(elt, target) {\n\t\tif (elt.closest && elt.closest(_hyperscript.config.disableSelector)) {\n\t\t\treturn;\n\t\t}\n\t\tvar internalData = getInternalData(elt);\n\t\tif (!internalData.initialized) {\n\t\t\tvar src = getScript(elt);\n\t\t\tif (src) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalData.initialized = true;\n\t\t\t\t\tinternalData.script = src;\n\t\t\t\t\tvar tokens = _lexer.tokenize(src);\n\t\t\t\t\tvar hyperScript = _parser.parseHyperScript(tokens);\n\t\t\t\t\tif (!hyperScript) return;\n\t\t\t\t\thyperScript.apply(target || elt, elt);\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\ttriggerEvent(target || elt, \"load\", {\n\t\t\t\t\t\t\thyperscript: true,\n\t\t\t\t\t\t});\n\t\t\t\t\t}, 1);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_runtime.triggerEvent(elt, \"exception\", {\n\t\t\t\t\t\terror: e,\n\t\t\t\t\t});\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\"hyperscript errors were found on the following element:\",\n\t\t\t\t\t\telt,\n\t\t\t\t\t\t\"\\n\\n\",\n\t\t\t\t\t\te.message,\n\t\t\t\t\t\te.stack\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar internalDataMap = new WeakMap\n\n\t/**\n\t* @param {Element} elt\n\t* @returns {Object}\n\t*/\n\tfunction getInternalData(elt) {\n\t\tvar internalData = internalDataMap.get(elt);\n\t\tif (typeof internalData === 'undefined') {\n\t\t\tinternalDataMap.set(elt, internalData = {});\n\t\t}\n\t\treturn internalData;\n\t}\n\n\t/**\n\t* @param {any} value\n\t* @param {string} typeString\n\t* @param {boolean} [nullOk]\n\t* @returns {boolean}\n\t*/\n\tfunction typeCheck(value, typeString, nullOk) {\n\t\tif (value == null && nullOk) {\n\t\t\treturn true;\n\t\t}\n\t\tvar typeName = Object.prototype.toString.call(value).slice(8, -1);\n\t\treturn typeName === typeString;\n\t}\n\n\tfunction getElementScope(context) {\n\t\tvar elt = context.meta && context.meta.owner;\n\t\tif (elt) {\n\t\t\tvar internalData = getInternalData(elt);\n\t\t\tvar scopeName = \"elementScope\";\n\t\t\tif (context.meta.feature && context.meta.feature.behavior) {\n\t\t\t\tscopeName = context.meta.feature.behavior + \"Scope\";\n\t\t\t}\n\t\t\tvar elementScope = getOrInitObject(internalData, scopeName);\n\t\t\treturn elementScope;\n\t\t} else {\n\t\t\treturn {}; // no element, return empty scope\n\t\t}\n\t}\n\n\t/**\n\t* @param {string} str\n\t* @param {Context} context\n\t* @returns {any}\n\t*/\n\tfunction resolveSymbol(str, context, type) {\n\t\tif (str === \"me\" || str === \"my\" || str === \"I\") {\n\t\t\treturn context[\"me\"];\n\t\t}\n\t\tif (str === \"it\" || str === \"its\") {\n\t\t\treturn context[\"result\"];\n\t\t}\n\t\tif (str === \"you\" || str === \"your\" || str === \"yourself\") {\n\t\t\treturn context[\"beingTold\"];\n\t\t} else {\n\t\t\tif (type === \"global\") {\n\t\t\t\treturn globalScope[str];\n\t\t\t} else if (type === \"element\") {\n\t\t\t\tvar elementScope = getElementScope(context);\n\t\t\t\treturn elementScope[str];\n\t\t\t} else if (type === \"local\") {\n\t\t\t\treturn context[str];\n\t\t\t} else {\n\t\t\t\t// meta scope (used for event conditionals)\n\t\t\t\tif (context.meta && context.meta.context) {\n\t\t\t\t\tvar fromMetaContext = context.meta.context[str];\n\t\t\t\t\tif (typeof fromMetaContext !== \"undefined\") {\n\t\t\t\t\t\treturn fromMetaContext;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// local scope\n\t\t\t\tvar fromContext = context[str];\n\t\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\t\treturn fromContext;\n\t\t\t\t} else {\n\t\t\t\t\t// element scope\n\t\t\t\t\tvar elementScope = getElementScope(context);\n\t\t\t\t\tfromContext = elementScope[str];\n\t\t\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\t\t\treturn fromContext;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// global scope\n\t\t\t\t\t\treturn globalScope[str];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setSymbol(str, context, type, value) {\n\t\tif (type === \"global\") {\n\t\t\tglobalScope[str] = value;\n\t\t} else if (type === \"element\") {\n\t\t\tvar elementScope = getElementScope(context);\n\t\t\telementScope[str] = value;\n\t\t} else if (type === \"local\") {\n\t\t\tcontext[str] = value;\n\t\t} else {\n\t\t\t// local scope\n\t\t\tvar fromContext = context[str];\n\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\tcontext[str] = value;\n\t\t\t} else {\n\t\t\t\t// element scope\n\t\t\t\tvar elementScope = getElementScope(context);\n\t\t\t\tfromContext = elementScope[str];\n\t\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\t\telementScope[str] = value;\n\t\t\t\t} else {\n\t\t\t\t\t// global scope\n\t\t\t\t\tfromContext = globalScope[str];\n\t\t\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\t\t\tglobalScope[str] = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext[str] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* @param {GrammarElement} command\n\t* @param {Context} context\n\t* @returns {undefined | GrammarElement}\n\t*/\n\tfunction findNext(command, context) {\n\t\tif (command) {\n\t\t\tif (command.resolveNext) {\n\t\t\t\treturn command.resolveNext(context);\n\t\t\t} else if (command.next) {\n\t\t\t\treturn command.next;\n\t\t\t} else {\n\t\t\t\treturn findNext(command.parent, context);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* @param {Object<string,any>} root\n\t* @param {string} property\n\t* @param {boolean} attribute\n\t* @returns {any}\n\t*/\n\tfunction resolveProperty(root, property, attribute) {\n\t\tif (root != null) {\n\t\t\tvar val = attribute && root.getAttribute ? root.getAttribute(property) : root[property];\n\t\t\tif (typeof val !== \"undefined\") {\n\t\t\t\treturn val;\n\t\t\t}\n\n\t\t\tif (shouldAutoIterate(root)) {\n\t\t\t\t// flat map\n\t\t\t\tvar result = [];\n\t\t\t\tfor (var component of root) {\n\t\t\t\t\tvar componentValue = attribute ? component.getAttribute(property) : component[property];\n\t\t\t\t\tif (componentValue) {\n\t\t\t\t\t\tresult.push(componentValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* @param {Element} elt\n\t* @param {string[]} nameSpace\n\t* @param {string} name\n\t* @param {any} value\n\t*/\n\tfunction assignToNamespace(elt, nameSpace, name, value) {\n\t\tlet root\n\t\tif (typeof document !== \"undefined\" && elt === document.body) {\n\t\t\troot = globalScope;\n\t\t} else {\n\t\t\troot = getHyperscriptFeatures(elt);\n\t\t}\n\t\twhile (nameSpace.length > 0) {\n\t\t\tvar propertyName = nameSpace.shift();\n\t\t\tvar newRoot = root[propertyName];\n\t\t\tif (newRoot == null) {\n\t\t\t\tnewRoot = {};\n\t\t\t\troot[propertyName] = newRoot;\n\t\t\t}\n\t\t\troot = newRoot;\n\t\t}\n\n\t\troot[name] = value;\n\t}\n\n\tfunction getHyperTrace(ctx, thrown) {\n\t\tvar trace = [];\n\t\tvar root = ctx;\n\t\twhile (root.meta.caller) {\n\t\t\troot = root.meta.caller;\n\t\t}\n\t\tif (root.meta.traceMap) {\n\t\t\treturn root.meta.traceMap.get(thrown, trace);\n\t\t}\n\t}\n\n\tfunction registerHyperTrace(ctx, thrown) {\n\t\tvar trace = [];\n\t\tvar root = null;\n\t\twhile (ctx != null) {\n\t\t\ttrace.push(ctx);\n\t\t\troot = ctx;\n\t\t\tctx = ctx.meta.caller;\n\t\t}\n\t\tif (root.meta.traceMap == null) {\n\t\t\troot.meta.traceMap = new Map(); // TODO - WeakMap?\n\t\t}\n\t\tif (!root.meta.traceMap.get(thrown)) {\n\t\t\tvar traceEntry = {\n\t\t\t\ttrace: trace,\n\t\t\t\tprint: function (logger) {\n\t\t\t\t\tlogger = logger || console.error;\n\t\t\t\t\tlogger(\"hypertrace /// \");\n\t\t\t\t\tvar maxLen = 0;\n\t\t\t\t\tfor (var i = 0; i < trace.length; i++) {\n\t\t\t\t\t\tmaxLen = Math.max(maxLen, trace[i].meta.feature.displayName.length);\n\t\t\t\t\t}\n\t\t\t\t\tfor (var i = 0; i < trace.length; i++) {\n\t\t\t\t\t\tvar traceElt = trace[i];\n\t\t\t\t\t\tlogger(\n\t\t\t\t\t\t\t\"  ->\",\n\t\t\t\t\t\t\ttraceElt.meta.feature.displayName.padEnd(maxLen + 2),\n\t\t\t\t\t\t\t\"-\",\n\t\t\t\t\t\t\ttraceElt.meta.owner\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t\troot.meta.traceMap.set(thrown, traceEntry);\n\t\t}\n\t}\n\n\t/**\n\t* @param {string} str\n\t* @returns {string}\n\t*/\n\tfunction escapeSelector(str) {\n\t\treturn str.replace(/:/g, function (str) {\n\t\t\treturn \"\\\\\" + str;\n\t\t});\n\t}\n\n\t/**\n\t* @param {any} value\n\t* @param {*} elt\n\t*/\n\tfunction nullCheck(value, elt) {\n\t\tif (value == null) {\n\t\t\tthrow new Error(elt.sourceFor() + \" is null\");\n\t\t}\n\t}\n\n\t/**\n\t* @param {any} value\n\t* @returns {boolean}\n\t*/\n\tfunction isEmpty(value) {\n\t\treturn value == undefined || value.length === 0;\n\t}\n\n\t/**\n\t* @param {Node} node\n\t* @returns {Document|ShadowRoot}\n\t*/\n\tfunction getRootNode(node) {\n\t\tvar rv = node.getRootNode();\n\t\tif (rv instanceof Document || rv instanceof ShadowRoot) return rv;\n\t\telse return document;\n\t}\n\n\t/** @type string | null */\n\t// @ts-ignore\n\tvar hyperscriptUrl = \"document\" in globalScope ? import.meta.url : null;\n\n\t/** @type {RuntimeObject} */\n\treturn {\n\t\ttypeCheck,\n\t\tforEach,\n\t\timplicitLoop,\n\t\ttriggerEvent,\n\t\tmatchesSelector,\n\t\tgetScript,\n\t\tprocessNode,\n\t\tevaluate,\n\t\tevaluateNoPromise,\n\t\tparse,\n\t\tgetScriptSelector,\n\t\tresolveSymbol,\n\t\tsetSymbol,\n\t\tmakeContext,\n\t\tfindNext,\n\t\tunifiedEval,\n\t\tconvertValue,\n\t\tunifiedExec,\n\t\tresolveProperty,\n\t\tassignToNamespace,\n\t\tregisterHyperTrace,\n\t\tgetHyperTrace,\n\t\tgetInternalData,\n\t\tgetHyperscriptFeatures,\n\t\tescapeSelector,\n\t\tnullCheck,\n\t\tisEmpty,\n\t\tgetRootNode,\n\t\thyperscriptUrl,\n\t\tHALT,\n\t};\n})();\n\n//====================================================================\n// Grammar\n//====================================================================\n{\n\t_parser.addLeafExpression(\"parenthesized\", function (parser, _runtime, tokens) {\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tvar follows = tokens.clearFollow();\n\t\t\ttry {\n\t\t\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\t\t} finally {\n\t\t\t\ttokens.restoreFollow(follows);\n\t\t\t}\n\t\t\ttokens.requireOpToken(\")\");\n\t\t\treturn expr;\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"string\", function (parser, runtime, tokens) {\n\t\tvar stringToken = tokens.matchTokenType(\"STRING\");\n\t\tif (!stringToken) return;\n\t\tvar rawValue = stringToken.value;\n\t\t/** @type {any[]} */\n\t\tvar args;\n\t\tif (stringToken.template) {\n\t\t\tvar innerTokens = _lexer.tokenize(rawValue, true);\n\t\t\targs = parser.parseStringTemplate(innerTokens);\n\t\t} else {\n\t\t\targs = [];\n\t\t}\n\t\treturn {\n\t\t\ttype: \"string\",\n\t\t\ttoken: stringToken,\n\t\t\targs: args,\n\t\t\top: function (context) {\n\t\t\t\tvar returnStr = \"\";\n\t\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\t\tvar val = arguments[i];\n\t\t\t\t\tif (val !== undefined) {\n\t\t\t\t\t\treturnStr += val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn returnStr;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\tif (args.length === 0) {\n\t\t\t\t\treturn rawValue;\n\t\t\t\t} else {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"nakedString\", function (parser, runtime, tokens) {\n\t\tif (tokens.hasMore()) {\n\t\t\tvar tokenArr = tokens.consumeUntilWhitespace();\n\t\t\ttokens.matchTokenType(\"WHITESPACE\");\n\t\t\treturn {\n\t\t\t\ttype: \"nakedString\",\n\t\t\t\ttokens: tokenArr,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn tokenArr\n\t\t\t\t\t\t.map(function (t) {\n\t\t\t\t\t\t\treturn t.value;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.join(\"\");\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"number\", function (parser, runtime, tokens) {\n\t\tvar number = tokens.matchTokenType(\"NUMBER\");\n\t\tif (!number) return;\n\t\tvar numberToken = number;\n\t\tvar value = parseFloat(number.value);\n\t\treturn {\n\t\t\ttype: \"number\",\n\t\t\tvalue: value,\n\t\t\tnumberToken: numberToken,\n\t\t\tevaluate: function () {\n\t\t\t\treturn value;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"idRef\", function (parser, runtime, tokens) {\n\t\tvar elementId = tokens.matchTokenType(\"ID_REF\");\n\t\tif (!elementId) return;\n\t\t// TODO - unify these two expression types\n\t\tif (elementId.template) {\n\t\t\tvar templateValue = elementId.value.substr(2, elementId.value.length - 2);\n\t\t\tvar innerTokens = _lexer.tokenize(templateValue);\n\t\t\tvar innerExpression = parser.requireElement(\"expression\", innerTokens);\n\t\t\treturn {\n\t\t\t\ttype: \"idRefTemplate\",\n\t\t\t\targs: [innerExpression],\n\t\t\t\top: function (context, arg) {\n\t\t\t\t\treturn runtime.getRootNode(context.me).getElementById(arg);\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tconst value = elementId.value.substr(1);\n\t\t\treturn {\n\t\t\t\ttype: \"idRef\",\n\t\t\t\tcss: elementId.value,\n\t\t\t\tvalue: value,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\truntime.getRootNode(context.me).getElementById(value)\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"classRef\", function (parser, runtime, tokens) {\n\t\tvar classRef = tokens.matchTokenType(\"CLASS_REF\");\n\n\t\tif (!classRef) return;\n\n\t\t// TODO - unify these two expression types\n\t\tif (classRef.template) {\n\t\t\tvar templateValue = classRef.value.substr(2, classRef.value.length - 2);\n\t\t\tvar innerTokens = _lexer.tokenize(templateValue);\n\t\t\tvar innerExpression = parser.requireElement(\"expression\", innerTokens);\n\t\t\treturn {\n\t\t\t\ttype: \"classRefTemplate\",\n\t\t\t\targs: [innerExpression],\n\t\t\t\top: function (context, arg) {\n\t\t\t\t\treturn new ElementCollection(\".\" + arg, context.me)\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tconst css = classRef.value;\n\t\t\treturn {\n\t\t\t\ttype: \"classRef\",\n\t\t\t\tcss: css,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn new ElementCollection(css, context.me)\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\tclass TemplatedQueryElementCollection extends ElementCollection {\n\t\tconstructor(css, relativeToElement, templateParts) {\n\t\t\tsuper(css, relativeToElement);\n\t\t\tthis.templateParts = templateParts;\n\t\t\tthis.elements = templateParts.filter(elt => elt instanceof Element);\n\t\t}\n\n\t\tget css() {\n\t\t\tlet rv = \"\", i = 0\n\t\t\tfor (const val of this.templateParts) {\n\t\t\t\tif (val instanceof Element) {\n\t\t\t\t\trv += \"[data-hs-query-id='\" + i++ + \"']\";\n\t\t\t\t} else rv += val;\n\t\t\t}\n\t\t\treturn rv;\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\tthis.elements.forEach((el, i) => el.dataset.hsQueryId = i);\n\t\t\tconst rv = super[Symbol.iterator]();\n\t\t\tthis.elements.forEach(el => el.removeAttribute('data-hs-query-id'));\n\t\t\treturn rv;\n\t\t}\n\t}\n\n\t_parser.addLeafExpression(\"queryRef\", function (parser, runtime, tokens) {\n\t\tvar queryStart = tokens.matchOpToken(\"<\");\n\t\tif (!queryStart) return;\n\t\tvar queryTokens = tokens.consumeUntil(\"/\");\n\t\ttokens.requireOpToken(\"/\");\n\t\ttokens.requireOpToken(\">\");\n\t\tvar queryValue = queryTokens\n\t\t\t.map(function (t) {\n\t\t\t\tif (t.type === \"STRING\") {\n\t\t\t\t\treturn '\"' + t.value + '\"';\n\t\t\t\t} else {\n\t\t\t\t\treturn t.value;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.join(\"\");\n\n\t\tif (queryValue.indexOf(\"$\") >= 0) {\n\t\t\tvar template = true;\n\t\t\tvar innerTokens = _lexer.tokenize(queryValue, true);\n\t\t\tvar args = parser.parseStringTemplate(innerTokens);\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"queryRef\",\n\t\t\tcss: queryValue,\n\t\t\targs: args,\n\t\t\top: function (context, ...args) {\n\t\t\t\tif (template) {\n\t\t\t\t\treturn new TemplatedQueryElementCollection(queryValue, context.me, args)\n\t\t\t\t} else {\n\t\t\t\t\treturn new ElementCollection(queryValue, context.me)\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"attributeRef\", function (parser, runtime, tokens) {\n\t\tvar attributeRef = tokens.matchTokenType(\"ATTRIBUTE_REF\");\n\t\tif (!attributeRef) return;\n\t\tvar outerVal = attributeRef.value;\n\t\tif (outerVal.indexOf(\"[\") === 0) {\n\t\t\tvar innerValue = outerVal.substring(2, outerVal.length - 1);\n\t\t} else {\n\t\t\tvar innerValue = outerVal.substring(1);\n\t\t}\n\t\tvar css = \"[\" + innerValue + \"]\";\n\t\tvar split = innerValue.split(\"=\");\n\t\tvar name = split[0];\n\t\tvar value = split[1];\n\t\tif (value) {\n\t\t\t// strip quotes\n\t\t\tif (value.indexOf('\"') === 0) {\n\t\t\t\tvalue = value.substring(1, value.length - 1);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttype: \"attributeRef\",\n\t\t\tname: name,\n\t\t\tcss: css,\n\t\t\tvalue: value,\n\t\t\top: function (context) {\n\t\t\t\tvar target = context.beingTold || context.me;\n\t\t\t\tif (target) {\n\t\t\t\t\treturn target.getAttribute(name);\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"objectKey\", function (parser, runtime, tokens) {\n\t\tvar token;\n\t\tif ((token = tokens.matchTokenType(\"STRING\"))) {\n\t\t\treturn {\n\t\t\t\ttype: \"objectKey\",\n\t\t\t\tkey: token.value,\n\t\t\t\tevaluate: function () {\n\t\t\t\t\treturn token.value;\n\t\t\t\t},\n\t\t\t};\n\t\t} else if (tokens.matchOpToken(\"[\")) {\n\t\t\tvar expr = parser.parseElement(\"expression\", tokens);\n\t\t\ttokens.requireOpToken(\"]\");\n\t\t\treturn {\n\t\t\t\ttype: \"objectKey\",\n\t\t\t\texpr: expr,\n\t\t\t\targs: [expr],\n\t\t\t\top: function (ctx, expr) {\n\t\t\t\t\treturn expr;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tvar key = \"\";\n\t\t\tdo {\n\t\t\t\ttoken = tokens.matchTokenType(\"IDENTIFIER\") || tokens.matchOpToken(\"-\");\n\t\t\t\tif (token) key += token.value;\n\t\t\t} while (token);\n\t\t\treturn {\n\t\t\t\ttype: \"objectKey\",\n\t\t\t\tkey: key,\n\t\t\t\tevaluate: function () {\n\t\t\t\t\treturn key;\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"objectLiteral\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"{\")) return;\n\t\tvar keyExpressions = [];\n\t\tvar valueExpressions = [];\n\t\tif (!tokens.matchOpToken(\"}\")) {\n\t\t\tdo {\n\t\t\t\tvar name = parser.requireElement(\"objectKey\", tokens);\n\t\t\t\ttokens.requireOpToken(\":\");\n\t\t\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\t\t\tvalueExpressions.push(value);\n\t\t\t\tkeyExpressions.push(name);\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\"}\");\n\t\t}\n\t\treturn {\n\t\t\ttype: \"objectLiteral\",\n\t\t\targs: [keyExpressions, valueExpressions],\n\t\t\top: function (context, keys, values) {\n\t\t\t\tvar returnVal = {};\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\treturnVal[keys[i]] = values[i];\n\t\t\t\t}\n\t\t\t\treturn returnVal;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"nakedNamedArgumentList\", function (parser, runtime, tokens) {\n\t\tvar fields = [];\n\t\tvar valueExpressions = [];\n\t\tif (tokens.currentToken().type === \"IDENTIFIER\") {\n\t\t\tdo {\n\t\t\t\tvar name = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t\ttokens.requireOpToken(\":\");\n\t\t\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\t\t\tvalueExpressions.push(value);\n\t\t\t\tfields.push({ name: name, value: value });\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t}\n\t\treturn {\n\t\t\ttype: \"namedArgumentList\",\n\t\t\tfields: fields,\n\t\t\targs: [valueExpressions],\n\t\t\top: function (context, values) {\n\t\t\t\tvar returnVal = { _namedArgList_: true };\n\t\t\t\tfor (var i = 0; i < values.length; i++) {\n\t\t\t\t\tvar field = fields[i];\n\t\t\t\t\treturnVal[field.name.value] = values[i];\n\t\t\t\t}\n\t\t\t\treturn returnVal;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"namedArgumentList\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"(\")) return;\n\t\tvar elt = parser.requireElement(\"nakedNamedArgumentList\", tokens);\n\t\ttokens.requireOpToken(\")\");\n\t\treturn elt;\n\t});\n\n\t_parser.addGrammarElement(\"symbol\", function (parser, runtime, tokens) {\n\t\t/** @type {SymbolScope} */\n\t\tvar type = \"default\";\n\t\tif (tokens.matchToken(\"global\")) {\n\t\t\ttype = \"global\";\n\t\t} else if (tokens.matchToken(\"element\") || tokens.matchToken(\"module\")) {\n\t\t\ttype = \"element\";\n\t\t\t// optional possessive\n\t\t\tif (tokens.matchOpToken(\"'\")) {\n\t\t\t\ttokens.requireToken(\"s\");\n\t\t\t}\n\t\t} else if (tokens.matchOpToken(\":\")) {\n\t\t\ttype = \"element\";\n\t\t} else if (tokens.matchToken(\"local\")) {\n\t\t\ttype = \"local\";\n\t\t}\n\t\tvar identifier = tokens.matchTokenType(\"IDENTIFIER\");\n\t\tif (identifier) {\n\t\t\tvar name = identifier.value;\n\t\t\tif (name.indexOf(\"$\") === 0 && name.length > 1) {\n\t\t\t\ttype = \"global\";\n\t\t\t\tname = name.substr(1);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: \"symbol\",\n\t\t\t\tsymbolType: type,\n\t\t\t\ttoken: identifier,\n\t\t\t\tname: name,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.resolveSymbol(name, context, type);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"implicitMeTarget\", function (parser, runtime, tokens) {\n\t\treturn {\n\t\t\ttype: \"implicitMeTarget\",\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn context.beingTold || context.me;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"boolean\", function (parser, runtime, tokens) {\n\t\tvar booleanLiteral = tokens.matchToken(\"true\") || tokens.matchToken(\"false\");\n\t\tif (!booleanLiteral) return;\n\t\tconst value = booleanLiteral.value === \"true\";\n\t\treturn {\n\t\t\ttype: \"boolean\",\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn value;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"null\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"null\")) {\n\t\t\treturn {\n\t\t\t\ttype: \"null\",\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"arrayLiteral\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"[\")) return;\n\t\tvar values = [];\n\t\tif (!tokens.matchOpToken(\"]\")) {\n\t\t\tdo {\n\t\t\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\t\t\tvalues.push(expr);\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\"]\");\n\t\t}\n\t\treturn {\n\t\t\ttype: \"arrayLiteral\",\n\t\t\tvalues: values,\n\t\t\targs: [values],\n\t\t\top: function (context, values) {\n\t\t\t\treturn values;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"blockLiteral\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"\\\\\")) return;\n\t\tvar args = [];\n\t\tvar arg1 = tokens.matchTokenType(\"IDENTIFIER\");\n\t\tif (arg1) {\n\t\t\targs.push(arg1);\n\t\t\twhile (tokens.matchOpToken(\",\")) {\n\t\t\t\targs.push(tokens.requireTokenType(\"IDENTIFIER\"));\n\t\t\t}\n\t\t}\n\t\t// TODO compound op token\n\t\ttokens.requireOpToken(\"-\");\n\t\ttokens.requireOpToken(\">\");\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\treturn {\n\t\t\ttype: \"blockLiteral\",\n\t\t\targs: args,\n\t\t\texpr: expr,\n\t\t\tevaluate: function (ctx) {\n\t\t\t\tvar returnFunc = function () {\n\t\t\t\t\t//TODO - push scope\n\t\t\t\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\t\t\t\tctx[args[i].value] = arguments[i];\n\t\t\t\t\t}\n\t\t\t\t\treturn expr.evaluate(ctx); //OK\n\t\t\t\t};\n\t\t\t\treturn returnFunc;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"timeExpression\", function (parser, runtime, tokens) {\n\t\tvar time = parser.requireElement(\"expression\", tokens);\n\t\tvar factor = 1;\n\t\tif (tokens.matchToken(\"s\") || tokens.matchToken(\"seconds\")) {\n\t\t\tfactor = 1000;\n\t\t} else if (tokens.matchToken(\"ms\") || tokens.matchToken(\"milliseconds\")) {\n\t\t\t// do nothing\n\t\t}\n\t\treturn {\n\t\t\ttype: \"timeExpression\",\n\t\t\ttime: time,\n\t\t\tfactor: factor,\n\t\t\targs: [time],\n\t\t\top: function (_context, val) {\n\t\t\t\treturn val * factor;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addIndirectExpression(\"propertyAccess\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchOpToken(\".\")) return;\n\t\tvar prop = tokens.requireTokenType(\"IDENTIFIER\");\n\t\tvar propertyAccess = {\n\t\t\ttype: \"propertyAccess\",\n\t\t\troot: root,\n\t\t\tprop: prop,\n\t\t\targs: [root],\n\t\t\top: function (_context, rootVal) {\n\t\t\t\tvar value = runtime.resolveProperty(rootVal, prop.value, false);\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t});\n\n\t_parser.addIndirectExpression(\"of\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchToken(\"of\")) return;\n\t\tvar newRoot = parser.requireElement(\"expression\", tokens);\n\t\t// find the urroot\n\t\tvar childOfUrRoot = null;\n\t\tvar urRoot = root;\n\t\twhile (urRoot.root) {\n\t\t\tchildOfUrRoot = urRoot;\n\t\t\turRoot = urRoot.root;\n\t\t}\n\t\tif (urRoot.type !== \"symbol\" && urRoot.type !== \"attributeRef\") {\n\t\t\tparser.raiseParseError(tokens, \"Cannot take a property of a non-symbol: \" + urRoot.type);\n\t\t}\n\t\tvar attribute = urRoot.type === \"attributeRef\";\n\t\tvar prop = urRoot.name;\n\t\tvar propertyAccess = {\n\t\t\ttype: \"ofExpression\",\n\t\t\tprop: urRoot.token,\n\t\t\troot: newRoot,\n\t\t\tattribute: attribute,\n\t\t\texpression: root,\n\t\t\targs: [newRoot],\n\t\t\top: function (context, rootVal) {\n\t\t\t\treturn runtime.resolveProperty(rootVal, prop, attribute);\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\n\t\tif (urRoot.type === \"attributeRef\") {\n\t\t\tpropertyAccess.attribute = urRoot;\n\t\t}\n\t\tif (childOfUrRoot) {\n\t\t\tchildOfUrRoot.root = propertyAccess;\n\t\t\tchildOfUrRoot.args = [propertyAccess];\n\t\t} else {\n\t\t\troot = propertyAccess;\n\t\t}\n\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, root);\n\t});\n\n\t_parser.addIndirectExpression(\"possessive\", function (parser, runtime, tokens, root) {\n\t\tif (parser.possessivesDisabled) {\n\t\t\treturn;\n\t\t}\n\t\tvar apostrophe = tokens.matchOpToken(\"'\");\n\t\tif (\n\t\t\tapostrophe ||\n\t\t\t(root.type === \"symbol\" &&\n\t\t\t\t(root.name === \"my\" || root.name === \"its\" || root.name === \"your\") &&\n\t\t\t\ttokens.currentToken().type === \"IDENTIFIER\")\n\t\t) {\n\t\t\tif (apostrophe) {\n\t\t\t\ttokens.requireToken(\"s\");\n\t\t\t}\n\t\t\tvar attribute = parser.parseElement(\"attributeRef\", tokens);\n\t\t\tif (attribute == null) {\n\t\t\t\tvar prop = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t}\n\t\t\tvar propertyAccess = {\n\t\t\t\ttype: \"possessive\",\n\t\t\t\troot: root,\n\t\t\t\tattribute: attribute,\n\t\t\t\tprop: prop,\n\t\t\t\targs: [root],\n\t\t\t\top: function (context, rootVal) {\n\t\t\t\t\tif (attribute) {\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvar value = runtime.resolveProperty(rootVal, attribute.name, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar value = runtime.resolveProperty(rootVal, prop.value, false);\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t\t}\n\t});\n\n\t_parser.addIndirectExpression(\"inExpression\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchToken(\"in\")) return;\n\t\tif ((root.type !== \"idRef\" && root.type === \"queryRef\") || root.type === \"classRef\") {\n\t\t\tvar query = true;\n\t\t}\n\t\tvar target = parser.requireElement(\"expression\", tokens);\n\t\tvar propertyAccess = {\n\t\t\ttype: \"inExpression\",\n\t\t\troot: root,\n\t\t\targs: [query ? null : root, target],\n\t\t\top: function (context, rootVal, target) {\n\t\t\t\tvar returnArr = [];\n\t\t\t\tif (query) {\n\t\t\t\t\truntime.forEach(target, function (targetElt) {\n\t\t\t\t\t\tvar results = targetElt.querySelectorAll(root.css);\n\t\t\t\t\t\tfor (var i = 0; i < results.length; i++) {\n\t\t\t\t\t\t\treturnArr.push(results[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\truntime.forEach(rootVal, function (rootElt) {\n\t\t\t\t\t\truntime.forEach(target, function (targetElt) {\n\t\t\t\t\t\t\tif (rootElt === targetElt) {\n\t\t\t\t\t\t\t\treturnArr.push(rootElt);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (returnArr.length > 0) {\n\t\t\t\t\treturn returnArr;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t});\n\n\t_parser.addIndirectExpression(\"asExpression\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchToken(\"as\")) return;\n\t\ttokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n\t\tvar conversion = parser.requireElement(\"dotOrColonPath\", tokens).evaluate(); // OK No promise\n\t\tvar propertyAccess = {\n\t\t\ttype: \"asExpression\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (context, rootVal) {\n\t\t\t\treturn runtime.convertValue(rootVal, conversion);\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t});\n\n\t_parser.addIndirectExpression(\"functionCall\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchOpToken(\"(\")) return;\n\t\tvar args = [];\n\t\tif (!tokens.matchOpToken(\")\")) {\n\t\t\tdo {\n\t\t\t\targs.push(parser.requireElement(\"expression\", tokens));\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\")\");\n\t\t}\n\n\t\tif (root.root) {\n\t\t\tvar functionCall = {\n\t\t\t\ttype: \"functionCall\",\n\t\t\t\troot: root,\n\t\t\t\targExressions: args,\n\t\t\t\targs: [root.root, args],\n\t\t\t\top: function (context, rootRoot, args) {\n\t\t\t\t\truntime.nullCheck(rootRoot, root.root);\n\t\t\t\t\tvar func = rootRoot[root.prop.value];\n\t\t\t\t\truntime.nullCheck(func, root);\n\t\t\t\t\tif (func.hyperfunc) {\n\t\t\t\t\t\targs.push(context);\n\t\t\t\t\t}\n\t\t\t\t\treturn func.apply(rootRoot, args);\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tvar functionCall = {\n\t\t\t\ttype: \"functionCall\",\n\t\t\t\troot: root,\n\t\t\t\targExressions: args,\n\t\t\t\targs: [root, args],\n\t\t\t\top: function (context, func, argVals) {\n\t\t\t\t\truntime.nullCheck(func, root);\n\t\t\t\t\tif (func.hyperfunc) {\n\t\t\t\t\t\targVals.push(context);\n\t\t\t\t\t}\n\t\t\t\t\tvar apply = func.apply(null, argVals);\n\t\t\t\t\treturn apply;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, functionCall);\n\t});\n\n\t_parser.addIndirectExpression(\"attributeRefAccess\", function (parser, runtime, tokens, root) {\n\t\tvar attribute = parser.parseElement(\"attributeRef\", tokens);\n\t\tif (!attribute) return;\n\t\tvar attributeAccess = {\n\t\t\ttype: \"attributeRefAccess\",\n\t\t\troot: root,\n\t\t\tattribute: attribute,\n\t\t\targs: [root],\n\t\t\top: function (_ctx, rootVal) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tvar value = runtime.resolveProperty(rootVal, attribute.name, true);\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn _runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn attributeAccess;\n\t});\n\n\t_parser.addIndirectExpression(\"arrayIndex\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchOpToken(\"[\")) return;\n\t\tvar andBefore = false;\n\t\tvar andAfter = false;\n\t\tvar firstIndex = null;\n\t\tvar secondIndex = null;\n\n\t\tif (tokens.matchOpToken(\"..\")) {\n\t\t\tandBefore = true;\n\t\t\tfirstIndex = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\tfirstIndex = parser.requireElement(\"expression\", tokens);\n\n\t\t\tif (tokens.matchOpToken(\"..\")) {\n\t\t\t\tandAfter = true;\n\t\t\t\tvar current = tokens.currentToken();\n\t\t\t\tif (current.type !== \"R_BRACKET\") {\n\t\t\t\t\tsecondIndex = parser.parseElement(\"expression\", tokens);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttokens.requireOpToken(\"]\");\n\n\t\tvar arrayIndex = {\n\t\t\ttype: \"arrayIndex\",\n\t\t\troot: root,\n\t\t\tfirstIndex: firstIndex,\n\t\t\tsecondIndex: secondIndex,\n\t\t\targs: [root, firstIndex, secondIndex],\n\t\t\top: function (_ctx, root, firstIndex, secondIndex) {\n\t\t\t\tif (andBefore) {\n\t\t\t\t\treturn root.slice(0, firstIndex + 1); // returns all items from beginning to firstIndex (inclusive)\n\t\t\t\t} else if (andAfter) {\n\t\t\t\t\tif (secondIndex != null) {\n\t\t\t\t\t\treturn root.slice(firstIndex, secondIndex + 1); // returns all items from firstIndex to secondIndex (inclusive)\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn root.slice(firstIndex); // returns from firstIndex to end of array\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn root[firstIndex];\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn _runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\n\t\treturn _parser.parseElement(\"indirectExpression\", tokens, arrayIndex);\n\t});\n\n\t_parser.addGrammarElement(\"postfixExpression\", function (parser, runtime, tokens) {\n\t\tvar root = parser.parseElement(\"primaryExpression\", tokens);\n\t\tif (tokens.matchOpToken(\":\")) {\n\t\t\tvar typeName = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\tvar nullOk = !tokens.matchOpToken(\"!\");\n\t\t\treturn {\n\t\t\t\ttype: \"typeCheck\",\n\t\t\t\ttypeName: typeName,\n\t\t\t\tnullOk: nullOk,\n\t\t\t\targs: [root],\n\t\t\t\top: function (context, val) {\n\t\t\t\t\tvar passed = runtime.typeCheck(val, typeName.value, nullOk);\n\t\t\t\t\tif (passed) {\n\t\t\t\t\t\treturn val;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"Typecheck failed!  Expected: \" + typeName.value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\treturn root;\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"logicalNot\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"not\")) return;\n\t\tvar root = parser.requireElement(\"unaryExpression\", tokens);\n\t\treturn {\n\t\t\ttype: \"logicalNot\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (context, val) {\n\t\t\t\treturn !val;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"noExpression\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"no\")) return;\n\t\tvar root = parser.requireElement(\"unaryExpression\", tokens);\n\t\treturn {\n\t\t\ttype: \"noExpression\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (_context, val) {\n\t\t\t\treturn runtime.isEmpty(val);\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"negativeNumber\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"-\")) return;\n\t\tvar root = parser.requireElement(\"unaryExpression\", tokens);\n\t\treturn {\n\t\t\ttype: \"negativeNumber\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (context, value) {\n\t\t\t\treturn -1 * value;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"unaryExpression\", function (parser, runtime, tokens) {\n\t\treturn parser.parseAnyOf(\n\t\t\t[\"logicalNot\", \"relativePositionalExpression\", \"positionalExpression\", \"noExpression\", \"negativeNumber\", \"postfixExpression\"],\n\t\t\ttokens\n\t\t);\n\t});\n\n\tvar scanForwardQuery = function(start, root, match, wrap) {\n\t\tvar results = root.querySelectorAll(match);\n\t\tfor (var i = 0; i < results.length; i++) {\n\t\t\tvar elt = results[i];\n\t\t\tif (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_PRECEDING) {\n\t\t\t\treturn elt;\n\t\t\t}\n\t\t}\n\t\tif (wrap) {\n\t\t\treturn results[0];\n\t\t}\n\t}\n\n\tvar scanBackwardsQuery = function(start, root, match, wrap) {\n\t\tvar results = root.querySelectorAll(match);\n\t\tfor (var i = results.length - 1; i >= 0; i--) {\n\t\t\tvar elt = results[i];\n\t\t\tif (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_FOLLOWING) {\n\t\t\t\treturn elt;\n\t\t\t}\n\t\t}\n\t\tif (wrap) {\n\t\t\treturn results[results.length - 1];\n\t\t}\n\t}\n\n\tvar scanForwardArray = function(start, array, match, wrap) {\n\t\tvar matches = [];\n\t\t_runtime.forEach(array, function(elt){\n\t\t\tif (elt.matches(match) || elt === start) {\n\t\t\t\tmatches.push(elt);\n\t\t\t}\n\t\t})\n\t\tfor (var i = 0; i < matches.length - 1; i++) {\n\t\t\tvar elt = matches[i];\n\t\t\tif (elt === start) {\n\t\t\t\treturn matches[i + 1];\n\t\t\t}\n\t\t}\n\t\tif (wrap) {\n\t\t\tvar first = matches[0];\n\t\t\tif (first && first.matches(match)) {\n\t\t\t\treturn first;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar scanBackwardsArray = function(start, array, match, wrap) {\n\t\treturn scanForwardArray(start, Array.from(array).reverse(), match, wrap);\n\t}\n\n\t_parser.addGrammarElement(\"relativePositionalExpression\", function (parser, runtime, tokens) {\n\t\tvar op = tokens.matchAnyToken(\"next\", \"previous\");\n\t\tif (!op) return;\n\t\tif (op.value === \"next\") {\n\t\t\tvar forwardSearch = true;\n\t\t}\n\n\t\tvar thing = parser.parseElement(\"expression\", tokens);\n\n\t\tif (tokens.matchToken(\"from\")) {\n\t\t\ttokens.pushFollow(\"in\");\n\t\t\ttry {\n\t\t\t\tvar from = parser.requireElement(\"expression\", tokens);\n\t\t\t} finally {\n\t\t\t\ttokens.popFollow();\n\t\t\t}\n\t\t} else {\n\t\t\tvar from = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t}\n\n\t\tvar inSearch = false;\n\t\tvar withinElt;\n\t\tif (tokens.matchToken(\"in\")) {\n\t\t\tinSearch = true;\n\t\t\tvar inElt = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"within\")) {\n\t\t\twithinElt = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\twithinElt = document.body;\n\t\t}\n\n\t\tvar wrapping = false;\n\t\tif (tokens.matchToken(\"with\")) {\n\t\t\ttokens.requireToken(\"wrapping\")\n\t\t\twrapping = true;\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"relativePositionalExpression\",\n\t\t\tfrom: from,\n\t\t\tforwardSearch: forwardSearch,\n\t\t\tinSearch: inSearch,\n\t\t\twrapping: wrapping,\n\t\t\tinElt: inElt,\n\t\t\twithinElt: withinElt,\n\t\t\toperator: op.value,\n\t\t\targs: [thing, from, inElt, withinElt],\n\t\t\top: function (context, thing, from, inElt, withinElt) {\n\n\t\t\t\tvar css = thing.css;\n\t\t\t\tif (css == null) {\n\t\t\t\t\tthrow \"Expected a CSS value\";\n\t\t\t\t}\n\n\t\t\t\tif(inSearch) {\n\t\t\t\t\tif (inElt) {\n\t\t\t\t\t\tif (forwardSearch) {\n\t\t\t\t\t\t\treturn scanForwardArray(from, inElt, css, wrapping);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn scanBackwardsArray(from, inElt, css, wrapping);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (withinElt) {\n\t\t\t\t\t\tif (forwardSearch) {\n\t\t\t\t\t\t\treturn scanForwardQuery(from, withinElt, css, wrapping);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn scanBackwardsQuery(from, withinElt, css, wrapping);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t}\n\n\t});\n\n\t_parser.addGrammarElement(\"positionalExpression\", function (parser, runtime, tokens) {\n\t\tvar op = tokens.matchAnyToken(\"first\", \"last\", \"random\");\n\t\tif (!op) return;\n\t\ttokens.matchAnyToken(\"in\", \"from\", \"of\");\n\t\tvar rhs = parser.requireElement(\"unaryExpression\", tokens);\n\t\tconst operator = op.value;\n\t\treturn {\n\t\t\ttype: \"positionalExpression\",\n\t\t\trhs: rhs,\n\t\t\toperator: op.value,\n\t\t\targs: [rhs],\n\t\t\top: function (context, rhsVal) {\n\t\t\t\tif (rhsVal && !Array.isArray(rhsVal)) {\n\t\t\t\t\tif (rhsVal.children) {\n\t\t\t\t\t\trhsVal = rhsVal.children;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trhsVal = Array.from(rhsVal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rhsVal) {\n\t\t\t\t\tif (operator === \"first\") {\n\t\t\t\t\t\treturn rhsVal[0];\n\t\t\t\t\t} else if (operator === \"last\") {\n\t\t\t\t\t\treturn rhsVal[rhsVal.length - 1];\n\t\t\t\t\t} else if (operator === \"random\") {\n\t\t\t\t\t\treturn rhsVal[Math.floor(Math.random() * rhsVal.length)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"mathOperator\", function (parser, runtime, tokens) {\n\t\tvar expr = parser.parseElement(\"unaryExpression\", tokens);\n\t\tvar mathOp,\n\t\t\tinitialMathOp = null;\n\t\tmathOp = tokens.matchAnyOpToken(\"+\", \"-\", \"*\", \"/\", \"%\");\n\t\twhile (mathOp) {\n\t\t\tinitialMathOp = initialMathOp || mathOp;\n\t\t\tvar operator = mathOp.value;\n\t\t\tif (initialMathOp.value !== operator) {\n\t\t\t\tparser.raiseParseError(tokens, \"You must parenthesize math operations with different operators\");\n\t\t\t}\n\t\t\tvar rhs = parser.parseElement(\"unaryExpression\", tokens);\n\t\t\texpr = {\n\t\t\t\ttype: \"mathOperator\",\n\t\t\t\tlhs: expr,\n\t\t\t\trhs: rhs,\n\t\t\t\toperator: operator,\n\t\t\t\targs: [expr, rhs],\n\t\t\t\top: function (context, lhsVal, rhsVal) {\n\t\t\t\t\tif (operator === \"+\") {\n\t\t\t\t\t\treturn lhsVal + rhsVal;\n\t\t\t\t\t} else if (operator === \"-\") {\n\t\t\t\t\t\treturn lhsVal - rhsVal;\n\t\t\t\t\t} else if (operator === \"*\") {\n\t\t\t\t\t\treturn lhsVal * rhsVal;\n\t\t\t\t\t} else if (operator === \"/\") {\n\t\t\t\t\t\treturn lhsVal / rhsVal;\n\t\t\t\t\t} else if (operator === \"%\") {\n\t\t\t\t\t\treturn lhsVal % rhsVal;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\tmathOp = tokens.matchAnyOpToken(\"+\", \"-\", \"*\", \"/\", \"%\");\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"mathExpression\", function (parser, runtime, tokens) {\n\t\treturn parser.parseAnyOf([\"mathOperator\", \"unaryExpression\"], tokens);\n\t});\n\n\tfunction sloppyContains(src, container, value){\n\t\tif (container['contains']) {\n\t\t\treturn container.contains(value);\n\t\t} else if (container['includes']) {\n\t\t\treturn container.includes(value);\n\t\t} else {\n\t\t\tthrow Error(\"The value of \" + src.sourceFor() + \" does not have a contains or includes method on it\");\n\t\t}\n\t}\n\tfunction sloppyMatches(src, target, toMatch){\n\t\tif (target['match']) {\n\t\t\treturn !!target.match(toMatch);\n\t\t} else if (target['matches']) {\n\t\t\treturn target.matches(toMatch);\n\t\t} else {\n\t\t\tthrow Error(\"The value of \" + src.sourceFor() + \" does not have a match or matches method on it\");\n\t\t}\n\t}\n\n\t_parser.addGrammarElement(\"comparisonOperator\", function (parser, runtime, tokens) {\n\t\tvar expr = parser.parseElement(\"mathExpression\", tokens);\n\t\tvar comparisonToken = tokens.matchAnyOpToken(\"<\", \">\", \"<=\", \">=\", \"==\", \"===\", \"!=\", \"!==\");\n\t\tvar operator = comparisonToken ? comparisonToken.value : null;\n\t\tvar hasRightValue = true; // By default, most comparisons require two values, but there are some exceptions.\n\t\tvar typeCheck = false;\n\n\t\tif (operator == null) {\n\t\t\tif (tokens.matchToken(\"is\") || tokens.matchToken(\"am\")) {\n\t\t\t\tif (tokens.matchToken(\"not\")) {\n\t\t\t\t\tif (tokens.matchToken(\"in\")) {\n\t\t\t\t\t\toperator = \"not in\";\n\t\t\t\t\t} else if (tokens.matchToken(\"a\")) {\n\t\t\t\t\t\toperator = \"not a\";\n\t\t\t\t\t\ttypeCheck = true;\n\t\t\t\t\t} else if (tokens.matchToken(\"empty\")) {\n\t\t\t\t\t\toperator = \"not empty\";\n\t\t\t\t\t\thasRightValue = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toperator = \"!=\";\n\t\t\t\t\t}\n\t\t\t\t} else if (tokens.matchToken(\"in\")) {\n\t\t\t\t\toperator = \"in\";\n\t\t\t\t} else if (tokens.matchToken(\"a\")) {\n\t\t\t\t\toperator = \"a\";\n\t\t\t\t\ttypeCheck = true;\n\t\t\t\t} else if (tokens.matchToken(\"empty\")) {\n\t\t\t\t\toperator = \"empty\";\n\t\t\t\t\thasRightValue = false;\n\t\t\t\t} else if (tokens.matchToken(\"less\")) {\n\t\t\t\t\ttokens.requireToken(\"than\");\n\t\t\t\t\tif (tokens.matchToken(\"or\")) {\n\t\t\t\t\t\ttokens.requireToken(\"equal\");\n\t\t\t\t\t\ttokens.requireToken(\"to\");\n\t\t\t\t\t\toperator = \"<=\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\toperator = \"<\";\n\t\t\t\t\t}\n\t\t\t\t} else if (tokens.matchToken(\"greater\")) {\n\t\t\t\t\ttokens.requireToken(\"than\");\n\t\t\t\t\tif (tokens.matchToken(\"or\")) {\n\t\t\t\t\t\ttokens.requireToken(\"equal\");\n\t\t\t\t\t\ttokens.requireToken(\"to\");\n\t\t\t\t\t\toperator = \">=\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\toperator = \">\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toperator = \"==\";\n\t\t\t\t}\n\t\t\t} else if (tokens.matchToken(\"matches\") || tokens.matchToken(\"match\")) {\n\t\t\t\toperator = \"match\";\n\t\t\t} else if (tokens.matchToken(\"contains\") || tokens.matchToken(\"contain\")) {\n\t\t\t\toperator = \"contain\";\n\t\t\t} else if (tokens.matchToken(\"includes\") || tokens.matchToken(\"include\")) {\n\t\t\t\toperator = \"include\";\n\t\t\t} else if (tokens.matchToken(\"do\") || tokens.matchToken(\"does\")) {\n\t\t\t\ttokens.requireToken(\"not\");\n\t\t\t\tif (tokens.matchToken(\"matches\") || tokens.matchToken(\"match\")) {\n\t\t\t\t\toperator = \"not match\";\n\t\t\t\t} else if (tokens.matchToken(\"contains\") || tokens.matchToken(\"contain\")) {\n\t\t\t\t\toperator = \"not contain\";\n\t\t\t\t} else if (tokens.matchToken(\"include\")) {\n\t\t\t\t\toperator = \"not include\";\n\t\t\t\t} else {\n\t\t\t\t\tparser.raiseParseError(tokens, \"Expected matches or contains\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (operator) {\n\t\t\t// Do not allow chained comparisons, which is dumb\n\t\t\tif (typeCheck) {\n\t\t\t\tvar typeName = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t\tvar nullOk = !tokens.matchOpToken(\"!\");\n\t\t\t} else if (hasRightValue) {\n\t\t\t\tvar rhs = parser.requireElement(\"mathExpression\", tokens);\n\t\t\t\tif (operator === \"match\" || operator === \"not match\") {\n\t\t\t\t\trhs = rhs.css ? rhs.css : rhs;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar lhs = expr;\n\t\t\texpr = {\n\t\t\t\ttype: \"comparisonOperator\",\n\t\t\t\toperator: operator,\n\t\t\t\ttypeName: typeName,\n\t\t\t\tnullOk: nullOk,\n\t\t\t\tlhs: expr,\n\t\t\t\trhs: rhs,\n\t\t\t\targs: [expr, rhs],\n\t\t\t\top: function (context, lhsVal, rhsVal) {\n\t\t\t\t\tif (operator === \"==\") {\n\t\t\t\t\t\treturn lhsVal == rhsVal;\n\t\t\t\t\t} else if (operator === \"!=\") {\n\t\t\t\t\t\treturn lhsVal != rhsVal;\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"match\") {\n\t\t\t\t\t\treturn lhsVal != null && sloppyMatches(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"not match\") {\n\t\t\t\t\t\treturn lhsVal == null || !sloppyMatches(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"in\") {\n\t\t\t\t\t\treturn rhsVal != null && sloppyContains(rhs, rhsVal, lhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"not in\") {\n\t\t\t\t\t\treturn rhsVal == null || !sloppyContains(rhs, rhsVal, lhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"contain\") {\n\t\t\t\t\t\treturn lhsVal != null && sloppyContains(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"not contain\") {\n\t\t\t\t\t\treturn lhsVal == null || !sloppyContains(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"include\") {\n\t\t\t\t\t\treturn lhsVal != null && sloppyContains(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"not include\") {\n\t\t\t\t\t\treturn lhsVal == null || !sloppyContains(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"===\") {\n\t\t\t\t\t\treturn lhsVal === rhsVal;\n\t\t\t\t\t} else if (operator === \"!==\") {\n\t\t\t\t\t\treturn lhsVal !== rhsVal;\n\t\t\t\t\t} else if (operator === \"<\") {\n\t\t\t\t\t\treturn lhsVal < rhsVal;\n\t\t\t\t\t} else if (operator === \">\") {\n\t\t\t\t\t\treturn lhsVal > rhsVal;\n\t\t\t\t\t} else if (operator === \"<=\") {\n\t\t\t\t\t\treturn lhsVal <= rhsVal;\n\t\t\t\t\t} else if (operator === \">=\") {\n\t\t\t\t\t\treturn lhsVal >= rhsVal;\n\t\t\t\t\t} else if (operator === \"empty\") {\n\t\t\t\t\t\treturn runtime.isEmpty(lhsVal);\n\t\t\t\t\t} else if (operator === \"not empty\") {\n\t\t\t\t\t\treturn !runtime.isEmpty(lhsVal);\n\t\t\t\t\t} else if (operator === \"a\") {\n\t\t\t\t\t\treturn runtime.typeCheck(lhsVal, typeName.value, nullOk);\n\t\t\t\t\t} else if (operator === \"not a\") {\n\t\t\t\t\t\treturn !runtime.typeCheck(lhsVal, typeName.value, nullOk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow \"Unknown comparison : \" + operator;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"comparisonExpression\", function (parser, runtime, tokens) {\n\t\treturn parser.parseAnyOf([\"comparisonOperator\", \"mathExpression\"], tokens);\n\t});\n\n\t_parser.addGrammarElement(\"logicalOperator\", function (parser, runtime, tokens) {\n\t\tvar expr = parser.parseElement(\"comparisonExpression\", tokens);\n\t\tvar logicalOp,\n\t\t\tinitialLogicalOp = null;\n\t\tlogicalOp = tokens.matchToken(\"and\") || tokens.matchToken(\"or\");\n\t\twhile (logicalOp) {\n\t\t\tinitialLogicalOp = initialLogicalOp || logicalOp;\n\t\t\tif (initialLogicalOp.value !== logicalOp.value) {\n\t\t\t\tparser.raiseParseError(tokens, \"You must parenthesize logical operations with different operators\");\n\t\t\t}\n\t\t\tvar rhs = parser.requireElement(\"comparisonExpression\", tokens);\n\t\t\tconst operator = logicalOp.value;\n\t\t\texpr = {\n\t\t\t\ttype: \"logicalOperator\",\n\t\t\t\toperator: operator,\n\t\t\t\tlhs: expr,\n\t\t\t\trhs: rhs,\n\t\t\t\targs: [expr, rhs],\n\t\t\t\top: function (context, lhsVal, rhsVal) {\n\t\t\t\t\tif (operator === \"and\") {\n\t\t\t\t\t\treturn lhsVal && rhsVal;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn lhsVal || rhsVal;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\tlogicalOp = tokens.matchToken(\"and\") || tokens.matchToken(\"or\");\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"logicalExpression\", function (parser, runtime, tokens) {\n\t\treturn parser.parseAnyOf([\"logicalOperator\", \"mathExpression\"], tokens);\n\t});\n\n\t_parser.addGrammarElement(\"asyncExpression\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"async\")) {\n\t\t\tvar value = parser.requireElement(\"logicalExpression\", tokens);\n\t\t\tvar expr = {\n\t\t\t\ttype: \"asyncExpression\",\n\t\t\t\tvalue: value,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tasyncWrapper: true,\n\t\t\t\t\t\tvalue: this.value.evaluate(context), //OK\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn expr;\n\t\t} else {\n\t\t\treturn parser.parseElement(\"logicalExpression\", tokens);\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"expression\", function (parser, runtime, tokens) {\n\t\ttokens.matchToken(\"the\"); // optional the\n\t\treturn parser.parseElement(\"asyncExpression\", tokens);\n\t});\n\n\t_parser.addGrammarElement(\"assignableExpression\", function (parser, runtime, tokens) {\n\t\ttokens.matchToken(\"the\"); // optional the\n\n\t\t// TODO obviously we need to generalize this as a left hand side / targetable concept\n\t\tvar expr = parser.parseElement(\"primaryExpression\", tokens);\n\t\tif (expr && (\n\t\t\texpr.type === \"symbol\" ||\n\t\t\texpr.type === \"ofExpression\" ||\n\t\t\texpr.type === \"propertyAccess\" ||\n\t\t\texpr.type === \"attributeRefAccess\" ||\n\t\t\texpr.type === \"attributeRef\" ||\n\t\t\texpr.type === \"possessive\")\n\t\t) {\n\t\t\treturn expr;\n\t\t} else {\n\t\t\t_parser.raiseParseError(\n\t\t\t\ttokens,\n\t\t\t\t\"A target expression must be writable.  The expression type '\" + (expr && expr.type) + \"' is not.\"\n\t\t\t);\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"hyperscript\", function (parser, runtime, tokens) {\n\t\tvar features = [];\n\n\t\tif (tokens.hasMore()) {\n\t\t\twhile (parser.featureStart(tokens.currentToken()) || tokens.currentToken().value === \"(\") {\n\t\t\t\tvar feature = parser.requireElement(\"feature\", tokens);\n\t\t\t\tfeatures.push(feature);\n\t\t\t\ttokens.matchToken(\"end\"); // optional end\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttype: \"hyperscript\",\n\t\t\tfeatures: features,\n\t\t\tapply: function (target, source, args) {\n\t\t\t\t// no op\n\t\t\t\tfor (const feature of features) {\n\t\t\t\t\tfeature.install(target, source, args);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t});\n\n\tvar parseEventArgs = function (tokens) {\n\t\tvar args = [];\n\t\t// handle argument list (look ahead 3)\n\t\tif (\n\t\t\ttokens.token(0).value === \"(\" &&\n\t\t\t(tokens.token(1).value === \")\" || tokens.token(2).value === \",\" || tokens.token(2).value === \")\")\n\t\t) {\n\t\t\ttokens.matchOpToken(\"(\");\n\t\t\tdo {\n\t\t\t\targs.push(tokens.requireTokenType(\"IDENTIFIER\"));\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\")\");\n\t\t}\n\t\treturn args;\n\t};\n\n\t_parser.addFeature(\"on\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"on\")) return;\n\t\tvar every = false;\n\t\tif (tokens.matchToken(\"every\")) {\n\t\t\tevery = true;\n\t\t}\n\t\tvar events = [];\n\t\tvar displayName = null;\n\t\tdo {\n\t\t\tvar on = parser.requireElement(\"eventName\", tokens, \"Expected event name\");\n\n\t\t\tvar eventName = on.evaluate(); // OK No Promise\n\n\t\t\tif (displayName) {\n\t\t\t\tdisplayName = displayName + \" or \" + eventName;\n\t\t\t} else {\n\t\t\t\tdisplayName = \"on \" + eventName;\n\t\t\t}\n\t\t\tvar args = parseEventArgs(tokens);\n\n\t\t\tvar filter = null;\n\t\t\tif (tokens.matchOpToken(\"[\")) {\n\t\t\t\tfilter = parser.requireElement(\"expression\", tokens);\n\t\t\t\ttokens.requireOpToken(\"]\");\n\t\t\t}\n\n\t\t\tif (tokens.currentToken().type === \"NUMBER\") {\n\t\t\t\tvar startCountToken = tokens.consumeToken();\n\t\t\t\tvar startCount = parseInt(startCountToken.value);\n\t\t\t\tif (tokens.matchToken(\"to\")) {\n\t\t\t\t\tvar endCountToken = tokens.consumeToken();\n\t\t\t\t\tvar endCount = parseInt(endCountToken.value);\n\t\t\t\t} else if (tokens.matchToken(\"and\")) {\n\t\t\t\t\tvar unbounded = true;\n\t\t\t\t\ttokens.requireToken(\"on\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (eventName === \"intersection\") {\n\t\t\t\tvar intersectionSpec = {};\n\t\t\t\tif (tokens.matchToken(\"with\")) {\n\t\t\t\t\tintersectionSpec[\"with\"] = parser.requireElement(\"expression\", tokens).evaluate();\n\t\t\t\t}\n\t\t\t\tif (tokens.matchToken(\"having\")) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (tokens.matchToken(\"margin\")) {\n\t\t\t\t\t\t\tintersectionSpec[\"rootMargin\"] = parser.requireElement(\"stringLike\", tokens).evaluate();\n\t\t\t\t\t\t} else if (tokens.matchToken(\"threshold\")) {\n\t\t\t\t\t\t\tintersectionSpec[\"threshold\"] = parser.requireElement(\"expression\", tokens).evaluate();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparser.raiseParseError(tokens, \"Unknown intersection config specification\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (tokens.matchToken(\"and\"));\n\t\t\t\t}\n\t\t\t} else if (eventName === \"mutation\") {\n\t\t\t\tvar mutationSpec = {};\n\t\t\t\tif (tokens.matchToken(\"of\")) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (tokens.matchToken(\"anything\")) {\n\t\t\t\t\t\t\tmutationSpec[\"attributes\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"subtree\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"characterData\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"childList\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"childList\")) {\n\t\t\t\t\t\t\tmutationSpec[\"childList\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"attributes\")) {\n\t\t\t\t\t\t\tmutationSpec[\"attributes\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"attributeOldValue\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"subtree\")) {\n\t\t\t\t\t\t\tmutationSpec[\"subtree\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"characterData\")) {\n\t\t\t\t\t\t\tmutationSpec[\"characterData\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"characterDataOldValue\"] = true;\n\t\t\t\t\t\t} else if (tokens.currentToken().type === \"ATTRIBUTE_REF\") {\n\t\t\t\t\t\t\tvar attribute = tokens.consumeToken();\n\t\t\t\t\t\t\tif (mutationSpec[\"attributeFilter\"] == null) {\n\t\t\t\t\t\t\t\tmutationSpec[\"attributeFilter\"] = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (attribute.value.indexOf(\"@\") == 0) {\n\t\t\t\t\t\t\t\tmutationSpec[\"attributeFilter\"].push(attribute.value.substring(1));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparser.raiseParseError(\n\t\t\t\t\t\t\t\t\ttokens,\n\t\t\t\t\t\t\t\t\t\"Only shorthand attribute references are allowed here\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparser.raiseParseError(tokens, \"Unknown mutation config specification\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (tokens.matchToken(\"or\"));\n\t\t\t\t} else {\n\t\t\t\t\tmutationSpec[\"attributes\"] = true;\n\t\t\t\t\tmutationSpec[\"characterData\"] = true;\n\t\t\t\t\tmutationSpec[\"childList\"] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar from = null;\n\t\t\tvar elsewhere = false;\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tif (tokens.matchToken(\"elsewhere\")) {\n\t\t\t\t\telsewhere = true;\n\t\t\t\t} else {\n\t\t\t\t\tfrom = parser.parseElement(\"expression\", tokens);\n\t\t\t\t\tif (!from) {\n\t\t\t\t\t\tparser.raiseParseError(tokens, 'Expected either target value or \"elsewhere\".');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// support both \"elsewhere\" and \"from elsewhere\"\n\t\t\tif (from === null && elsewhere === false && tokens.matchToken(\"elsewhere\")) {\n\t\t\t\telsewhere = true;\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"in\")) {\n\t\t\t\tvar inExpr = parser.parseAnyOf([\"idRef\", \"queryRef\", \"classRef\"], tokens);\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"debounced\")) {\n\t\t\t\ttokens.requireToken(\"at\");\n\t\t\t\tvar timeExpr = parser.requireElement(\"timeExpression\", tokens);\n\t\t\t\t// @ts-ignore\n\t\t\t\tvar debounceTime = timeExpr.evaluate({}); // OK No promise TODO make a literal time expr\n\t\t\t} else if (tokens.matchToken(\"throttled\")) {\n\t\t\t\ttokens.requireToken(\"at\");\n\t\t\t\tvar timeExpr = parser.requireElement(\"timeExpression\", tokens);\n\t\t\t\t// @ts-ignore\n\t\t\t\tvar throttleTime = timeExpr.evaluate({}); // OK No promise TODO make a literal time expr\n\t\t\t}\n\n\t\t\tevents.push({\n\t\t\t\texecCount: 0,\n\t\t\t\tevery: every,\n\t\t\t\ton: eventName,\n\t\t\t\targs: args,\n\t\t\t\tfilter: filter,\n\t\t\t\tfrom: from,\n\t\t\t\tinExpr: inExpr,\n\t\t\t\telsewhere: elsewhere,\n\t\t\t\tstartCount: startCount,\n\t\t\t\tendCount: endCount,\n\t\t\t\tunbounded: unbounded,\n\t\t\t\tdebounceTime: debounceTime,\n\t\t\t\tthrottleTime: throttleTime,\n\t\t\t\tmutationSpec: mutationSpec,\n\t\t\t\tintersectionSpec: intersectionSpec,\n\t\t\t\tdebounced: undefined,\n\t\t\t\tlastExec: undefined,\n\t\t\t});\n\t\t} while (tokens.matchToken(\"or\"));\n\n\t\tvar queue = [];\n\t\tvar queueLast = true;\n\t\tif (!every) {\n\t\t\tif (tokens.matchToken(\"queue\")) {\n\t\t\t\tif (tokens.matchToken(\"all\")) {\n\t\t\t\t\tvar queueAll = true;\n\t\t\t\t\tvar queueLast = false;\n\t\t\t\t} else if (tokens.matchToken(\"first\")) {\n\t\t\t\t\tvar queueFirst = true;\n\t\t\t\t} else if (tokens.matchToken(\"none\")) {\n\t\t\t\t\tvar queueNone = true;\n\t\t\t\t} else {\n\t\t\t\t\ttokens.requireToken(\"last\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar commandList = parser.parseElement(\"commandList\", tokens);\n\n\t\tvar implicitReturn = {\n\t\t\ttype: \"implicitReturn\",\n\t\t\top: function (context) {\n\t\t\t\t// automatically resolve at the end of an event handler if nothing else does\n\t\t\t\tcontext.meta.resolve();\n\t\t\t\treturn runtime.HALT;\n\t\t\t},\n\t\t\texecute: function (ctx) {\n\t\t\t\t// do nothing\n\t\t\t},\n\t\t};\n\n\t\tif (commandList) {\n\t\t\t/** @type {GrammarElement} */\n\t\t\tvar start = commandList;\n\n\t\t\tvar end = start;\n\t\t\twhile (end.next) {\n\t\t\t\tend = end.next;\n\t\t\t}\n\t\t\tend.next = implicitReturn;\n\t\t} else {\n\t\t\tstart = implicitReturn;\n\t\t}\n\n\t\tvar onFeature = {\n\t\t\tdisplayName: displayName,\n\t\t\tevents: events,\n\t\t\tstart: start,\n\t\t\tevery: every,\n\t\t\texecuting: false,\n\t\t\texecCount: 0,\n\t\t\tqueue: queue,\n\t\t\texecute: function (/** @type {Context} */ ctx) {\n\t\t\t\tif (this.executing && every === false) {\n\t\t\t\t\tif (queueNone || (queueFirst && queue.length > 0)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (queueLast) {\n\t\t\t\t\t\tonFeature.queue.length = 0;\n\t\t\t\t\t}\n\t\t\t\t\tonFeature.queue.push(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tonFeature.execCount++;\n\t\t\t\tthis.executing = true;\n\t\t\t\tctx.meta.resolve = function () {\n\t\t\t\t\tonFeature.executing = false;\n\t\t\t\t\tvar queued = onFeature.queue.shift();\n\t\t\t\t\tif (queued) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tonFeature.execute(queued);\n\t\t\t\t\t\t}, 1);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tctx.meta.reject = function (err) {\n\t\t\t\t\tconsole.error(err.message ? err.message : err);\n\t\t\t\t\tvar hypertrace = runtime.getHyperTrace(ctx, err);\n\t\t\t\t\tif (hypertrace) {\n\t\t\t\t\t\thypertrace.print();\n\t\t\t\t\t}\n\t\t\t\t\truntime.triggerEvent(ctx.me, \"exception\", {\n\t\t\t\t\t\terror: err,\n\t\t\t\t\t});\n\t\t\t\t\tonFeature.executing = false;\n\t\t\t\t\tvar queued = onFeature.queue.shift();\n\t\t\t\t\tif (queued) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tonFeature.execute(queued);\n\t\t\t\t\t\t}, 1);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tstart.execute(ctx);\n\t\t\t},\n\t\t\tinstall: function (elt, source) {\n\t\t\t\tfor (const eventSpec of onFeature.events) {\n\t\t\t\t\tvar targets;\n\t\t\t\t\tif (eventSpec.elsewhere) {\n\t\t\t\t\t\ttargets = [document];\n\t\t\t\t\t} else if (eventSpec.from) {\n\t\t\t\t\t\ttargets = eventSpec.from.evaluate(runtime.makeContext(elt, onFeature, elt, null));\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttargets = [elt];\n\t\t\t\t\t}\n\t\t\t\t\truntime.forEach(targets, function (target) {\n\t\t\t\t\t\t// OK NO PROMISE\n\n\t\t\t\t\t\tvar eventName = eventSpec.on;\n\t\t\t\t\t\tif (eventSpec.mutationSpec) {\n\t\t\t\t\t\t\teventName = \"hyperscript:mutation\";\n\t\t\t\t\t\t\tconst observer = new MutationObserver(function (mutationList, observer) {\n\t\t\t\t\t\t\t\tconsole.log(target, mutationList);\n\t\t\t\t\t\t\t\tif (!onFeature.executing) {\n\t\t\t\t\t\t\t\t\t_runtime.triggerEvent(target, eventName, {\n\t\t\t\t\t\t\t\t\t\tmutationList: mutationList,\n\t\t\t\t\t\t\t\t\t\tobserver: observer,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tobserver.observe(target, eventSpec.mutationSpec);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (eventSpec.intersectionSpec) {\n\t\t\t\t\t\t\teventName = \"hyperscript:insersection\";\n\t\t\t\t\t\t\tconst observer = new IntersectionObserver(function (entries) {\n\t\t\t\t\t\t\t\tfor (const entry of entries) {\n\t\t\t\t\t\t\t\t\tvar detail = {\n\t\t\t\t\t\t\t\t\t\tobserver: observer,\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tdetail = mergeObjects(detail, entry);\n\t\t\t\t\t\t\t\t\tdetail[\"intersecting\"] = entry.isIntersecting;\n\t\t\t\t\t\t\t\t\t_runtime.triggerEvent(target, eventName, detail);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, eventSpec.intersectionSpec);\n\t\t\t\t\t\t\tobserver.observe(target);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar addEventListener = target.addEventListener || target.on;\n\t\t\t\t\t\taddEventListener.call(target, eventName, function listener(evt) {\n\t\t\t\t\t\t\t// OK NO PROMISE\n\t\t\t\t\t\t\tif (typeof Node !== 'undefined' && elt instanceof Node && target !== elt && !elt.isConnected) {\n\t\t\t\t\t\t\t\ttarget.removeEventListener(eventName, listener);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar ctx = runtime.makeContext(elt, onFeature, elt, evt);\n\t\t\t\t\t\t\tif (eventSpec.elsewhere && elt.contains(evt.target)) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (eventSpec.from) {\n\t\t\t\t\t\t\t\tctx.result = target;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// establish context\n\t\t\t\t\t\t\tfor (const arg of eventSpec.args) {\n\t\t\t\t\t\t\t\tctx[arg.value] =\n\t\t\t\t\t\t\t\t\tctx.event[arg.value] || ('detail' in ctx.event ? ctx.event['detail'][arg.value] : null);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// apply filter\n\t\t\t\t\t\t\tif (eventSpec.filter) {\n\t\t\t\t\t\t\t\tvar initialCtx = ctx.meta.context;\n\t\t\t\t\t\t\t\tctx.meta.context = ctx.event;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tvar value = eventSpec.filter.evaluate(ctx); //OK NO PROMISE\n\t\t\t\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\t\t\t\t// match the javascript semantics for if statements\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\tctx.meta.context = initialCtx;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (eventSpec.inExpr) {\n\t\t\t\t\t\t\t\tvar inElement = evt.target;\n\t\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\t\tif (inElement.matches && inElement.matches(eventSpec.inExpr.css)) {\n\t\t\t\t\t\t\t\t\t\tctx.result = inElement;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tinElement = inElement.parentElement;\n\t\t\t\t\t\t\t\t\t\tif (inElement == null) {\n\t\t\t\t\t\t\t\t\t\t\treturn; // no match found\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// verify counts\n\t\t\t\t\t\t\teventSpec.execCount++;\n\t\t\t\t\t\t\tif (eventSpec.startCount) {\n\t\t\t\t\t\t\t\tif (eventSpec.endCount) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\teventSpec.execCount < eventSpec.startCount ||\n\t\t\t\t\t\t\t\t\t\teventSpec.execCount > eventSpec.endCount\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (eventSpec.unbounded) {\n\t\t\t\t\t\t\t\t\tif (eventSpec.execCount < eventSpec.startCount) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (eventSpec.execCount !== eventSpec.startCount) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//debounce\n\t\t\t\t\t\t\tif (eventSpec.debounceTime) {\n\t\t\t\t\t\t\t\tif (eventSpec.debounced) {\n\t\t\t\t\t\t\t\t\tclearTimeout(eventSpec.debounced);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teventSpec.debounced = setTimeout(function () {\n\t\t\t\t\t\t\t\t\tonFeature.execute(ctx);\n\t\t\t\t\t\t\t\t}, eventSpec.debounceTime);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// throttle\n\t\t\t\t\t\t\tif (eventSpec.throttleTime) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\teventSpec.lastExec &&\n\t\t\t\t\t\t\t\t\tDate.now() < eventSpec.lastExec + eventSpec.throttleTime\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\teventSpec.lastExec = Date.now();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// apply execute\n\t\t\t\t\t\t\tonFeature.execute(ctx);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\tparser.setParent(start, onFeature);\n\t\treturn onFeature;\n\t});\n\n\t_parser.addFeature(\"def\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"def\")) return;\n\t\tvar functionName = parser.requireElement(\"dotOrColonPath\", tokens);\n\t\tvar nameVal = functionName.evaluate(); // OK\n\t\tvar nameSpace = nameVal.split(\".\");\n\t\tvar funcName = nameSpace.pop();\n\n\t\tvar args = [];\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tif (tokens.matchOpToken(\")\")) {\n\t\t\t\t// emtpy args list\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\targs.push(tokens.requireTokenType(\"IDENTIFIER\"));\n\t\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\t\ttokens.requireOpToken(\")\");\n\t\t\t}\n\t\t}\n\n\t\tvar start = parser.requireElement(\"commandList\", tokens);\n\t\tif (tokens.matchToken(\"catch\")) {\n\t\t\tvar errorSymbol = tokens.requireTokenType(\"IDENTIFIER\").value;\n\t\t\tvar errorHandler = parser.parseElement(\"commandList\", tokens);\n\t\t}\n\t\tvar functionFeature = {\n\t\t\tdisplayName:\n\t\t\t\tfuncName +\n\t\t\t\t\"(\" +\n\t\t\t\targs\n\t\t\t\t\t.map(function (arg) {\n\t\t\t\t\t\treturn arg.value;\n\t\t\t\t\t})\n\t\t\t\t\t.join(\", \") +\n\t\t\t\t\")\",\n\t\t\tname: funcName,\n\t\t\targs: args,\n\t\t\tstart: start,\n\t\t\terrorHandler: errorHandler,\n\t\t\terrorSymbol: errorSymbol,\n\t\t\tinstall: function (target, source) {\n\t\t\t\tvar func = function () {\n\t\t\t\t\t// null, worker\n\t\t\t\t\tvar ctx = runtime.makeContext(source, functionFeature, target, null);\n\n\t\t\t\t\t// install error handler if any\n\t\t\t\t\tctx.meta.errorHandler = errorHandler;\n\t\t\t\t\tctx.meta.errorSymmbol = errorSymbol;\n\n\t\t\t\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\t\t\t\tvar name = args[i];\n\t\t\t\t\t\tvar argumentVal = arguments[i];\n\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\tctx[name.value] = argumentVal;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctx.meta.caller = arguments[args.length];\n\t\t\t\t\tif (ctx.meta.caller) {\n\t\t\t\t\t\tctx.meta.callingCommand = ctx.meta.caller.meta.command;\n\t\t\t\t\t}\n\t\t\t\t\tvar resolve,\n\t\t\t\t\t\treject = null;\n\t\t\t\t\tvar promise = new Promise(function (theResolve, theReject) {\n\t\t\t\t\t\tresolve = theResolve;\n\t\t\t\t\t\treject = theReject;\n\t\t\t\t\t});\n\t\t\t\t\tstart.execute(ctx);\n\t\t\t\t\tif (ctx.meta.returned) {\n\t\t\t\t\t\treturn ctx.meta.returnValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.meta.resolve = resolve;\n\t\t\t\t\t\tctx.meta.reject = reject;\n\t\t\t\t\t\treturn promise;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfunc.hyperfunc = true;\n\t\t\t\tfunc.hypername = nameVal;\n\t\t\t\truntime.assignToNamespace(target, nameSpace, funcName, func);\n\t\t\t},\n\t\t};\n\n\t\tvar implicitReturn = {\n\t\t\ttype: \"implicitReturn\",\n\t\t\top: function (context) {\n\t\t\t\t// automatically return at the end of the function if nothing else does\n\t\t\t\tcontext.meta.returned = true;\n\t\t\t\tif (context.meta.resolve) {\n\t\t\t\t\tcontext.meta.resolve();\n\t\t\t\t}\n\t\t\t\treturn runtime.HALT;\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\t// do nothing\n\t\t\t},\n\t\t};\n\t\t// terminate body\n\t\tif (start) {\n\t\t\tvar end = start;\n\t\t\twhile (end.next) {\n\t\t\t\tend = end.next;\n\t\t\t}\n\t\t\tend.next = implicitReturn;\n\t\t} else {\n\t\t\tfunctionFeature.start = implicitReturn;\n\t\t}\n\n\t\t// terminate error handler\n\t\tif (errorHandler) {\n\t\t\tvar end = errorHandler;\n\t\t\twhile (end.next) {\n\t\t\t\tend = end.next;\n\t\t\t}\n\t\t\tend.next = implicitReturn;\n\t\t}\n\n\t\tparser.setParent(start, functionFeature);\n\t\treturn functionFeature;\n\t});\n\n\t_parser.addFeature(\"init\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"init\")) return;\n\t\tvar immediately = tokens.matchToken('immediately');\n\n\t\tvar start = parser.parseElement(\"commandList\", tokens);\n\t\tvar initFeature = {\n\t\t\tstart: start,\n\t\t\tinstall: function (target, source) {\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tstart && start.execute(runtime.makeContext(target, initFeature, target, null));\n\t\t\t\t}, 0);\n\t\t\t},\n\t\t};\n\n\t\tvar implicitReturn = {\n\t\t\ttype: \"implicitReturn\",\n\t\t\top: function (context) {\n\t\t\t\treturn runtime.HALT;\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\t// do nothing\n\t\t\t},\n\t\t};\n\t\t// terminate body\n\t\tif (start) {\n\t\t\tvar end = start;\n\t\t\twhile (end.next) {\n\t\t\t\tend = end.next;\n\t\t\t}\n\t\t\tend.next = implicitReturn;\n\t\t} else {\n\t\t\tinitFeature.start = implicitReturn;\n\t\t}\n\t\tparser.setParent(start, initFeature);\n\t\treturn initFeature;\n\t});\n\n\t_parser.addFeature(\"worker\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"worker\")) {\n\t\t\tparser.raiseParseError(\n\t\t\t\ttokens,\n\t\t\t\t\"In order to use the 'worker' feature, include \" +\n\t\t\t\t\t\"the _hyperscript worker plugin. See \" +\n\t\t\t\t\t\"https://hyperscript.org/features/worker/ for \" +\n\t\t\t\t\t\"more info.\"\n\t\t\t);\n\t\t}\n\t});\n\n\t_parser.addFeature(\"behavior\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"behavior\")) return;\n\t\tvar path = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n\t\tvar nameSpace = path.split(\".\");\n\t\tvar name = nameSpace.pop();\n\n\t\tvar formalParams = [];\n\t\tif (tokens.matchOpToken(\"(\") && !tokens.matchOpToken(\")\")) {\n\t\t\tdo {\n\t\t\t\tformalParams.push(tokens.requireTokenType(\"IDENTIFIER\").value);\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\")\");\n\t\t}\n\t\tvar hs = parser.requireElement(\"hyperscript\", tokens);\n\t\tfor (var i = 0; i < hs.features.length; i++) {\n\t\t\tvar feature = hs.features[i];\n\t\t\tfeature.behavior = path;\n\t\t}\n\n\t\treturn {\n\t\t\tinstall: function (target, source) {\n\t\t\t\truntime.assignToNamespace(\n\t\t\t\t\tglobalScope.document && globalScope.document.body,\n\t\t\t\t\tnameSpace,\n\t\t\t\t\tname,\n\t\t\t\t\tfunction (target, source, innerArgs) {\n\t\t\t\t\t\tvar internalData = runtime.getInternalData(target);\n\t\t\t\t\t\tvar elementScope = getOrInitObject(internalData, path + \"Scope\");\n\t\t\t\t\t\tfor (var i = 0; i < formalParams.length; i++) {\n\t\t\t\t\t\t\telementScope[formalParams[i]] = innerArgs[formalParams[i]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ths.apply(target, source);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addFeature(\"install\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"install\")) return;\n\t\tvar behaviorPath = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n\t\tvar behaviorNamespace = behaviorPath.split(\".\");\n\t\tvar args = parser.parseElement(\"namedArgumentList\", tokens);\n\n\t\tvar installFeature;\n\t\treturn (installFeature = {\n\t\t\tinstall: function (target, source) {\n\t\t\t\truntime.unifiedEval(\n\t\t\t\t\t{\n\t\t\t\t\t\targs: [args],\n\t\t\t\t\t\top: function (ctx, args) {\n\t\t\t\t\t\t\tvar behavior = globalScope;\n\t\t\t\t\t\t\tfor (var i = 0; i < behaviorNamespace.length; i++) {\n\t\t\t\t\t\t\t\tbehavior = behavior[behaviorNamespace[i]];\n\t\t\t\t\t\t\t\tif (typeof behavior !== \"object\" && typeof behavior !== \"function\")\n\t\t\t\t\t\t\t\t\tthrow new Error(\"No such behavior defined as \" + behaviorPath);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!(behavior instanceof Function))\n\t\t\t\t\t\t\t\tthrow new Error(behaviorPath + \" is not a behavior\");\n\n\t\t\t\t\t\t\tbehavior(target, source, args);\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\truntime.makeContext(target, installFeature, target)\n\t\t\t\t);\n\t\t\t},\n\t\t});\n\t});\n\n\t_parser.addGrammarElement(\"jsBody\", function (parser, runtime, tokens) {\n\t\tvar jsSourceStart = tokens.currentToken().start;\n\t\tvar jsLastToken = tokens.currentToken();\n\n\t\tvar funcNames = [];\n\t\tvar funcName = \"\";\n\t\tvar expectFunctionDeclaration = false;\n\t\twhile (tokens.hasMore()) {\n\t\t\tjsLastToken = tokens.consumeToken();\n\t\t\tvar peek = tokens.token(0, true);\n\t\t\tif (peek.type === \"IDENTIFIER\" && peek.value === \"end\") {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (expectFunctionDeclaration) {\n\t\t\t\tif (jsLastToken.type === \"IDENTIFIER\" || jsLastToken.type === \"NUMBER\") {\n\t\t\t\t\tfuncName += jsLastToken.value;\n\t\t\t\t} else {\n\t\t\t\t\tif (funcName !== \"\") funcNames.push(funcName);\n\t\t\t\t\tfuncName = \"\";\n\t\t\t\t\texpectFunctionDeclaration = false;\n\t\t\t\t}\n\t\t\t} else if (jsLastToken.type === \"IDENTIFIER\" && jsLastToken.value === \"function\") {\n\t\t\t\texpectFunctionDeclaration = true;\n\t\t\t}\n\t\t}\n\t\tvar jsSourceEnd = jsLastToken.end + 1;\n\n\t\treturn {\n\t\t\ttype: \"jsBody\",\n\t\t\texposedFunctionNames: funcNames,\n\t\t\tjsSource: tokens.source.substring(jsSourceStart, jsSourceEnd),\n\t\t};\n\t});\n\n\t_parser.addFeature(\"js\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"js\")) return;\n\t\tvar jsBody = parser.requireElement(\"jsBody\", tokens);\n\n\t\tvar jsSource =\n\t\t\tjsBody.jsSource +\n\t\t\t\"\\nreturn { \" +\n\t\t\tjsBody.exposedFunctionNames\n\t\t\t\t.map(function (name) {\n\t\t\t\t\treturn name + \":\" + name;\n\t\t\t\t})\n\t\t\t\t.join(\",\") +\n\t\t\t\" } \";\n\t\tvar func = new Function(jsSource);\n\n\t\treturn {\n\t\t\tjsSource: jsSource,\n\t\t\tfunction: func,\n\t\t\texposedFunctionNames: jsBody.exposedFunctionNames,\n\t\t\tinstall: function () {\n\t\t\t\tmergeObjects(globalScope, func());\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addCommand(\"js\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"js\")) return;\n\t\t// Parse inputs\n\t\tvar inputs = [];\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tif (tokens.matchOpToken(\")\")) {\n\t\t\t\t// empty input list\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tvar inp = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t\t\tinputs.push(inp.value);\n\t\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\t\ttokens.requireOpToken(\")\");\n\t\t\t}\n\t\t}\n\n\t\tvar jsBody = parser.requireElement(\"jsBody\", tokens);\n\t\ttokens.matchToken(\"end\");\n\n\t\tvar func = varargConstructor(Function, inputs.concat([jsBody.jsSource]));\n\n\t\tvar command = {\n\t\t\tjsSource: jsBody.jsSource,\n\t\t\tfunction: func,\n\t\t\tinputs: inputs,\n\t\t\top: function (context) {\n\t\t\t\tvar args = [];\n\t\t\t\tinputs.forEach(function (input) {\n\t\t\t\t\targs.push(runtime.resolveSymbol(input, context, 'default'));\n\t\t\t\t});\n\t\t\t\tvar result = func.apply(globalScope, args);\n\t\t\t\tif (result && typeof result.then === \"function\") {\n\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\tresult.then(function (actualResult) {\n\t\t\t\t\t\t\tcontext.result = actualResult;\n\t\t\t\t\t\t\tresolve(runtime.findNext(this, context));\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcontext.result = result;\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"async\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"async\")) return;\n\t\tif (tokens.matchToken(\"do\")) {\n\t\t\tvar body = parser.requireElement(\"commandList\", tokens);\n\n\t\t\t// Append halt\n\t\t\tvar end = body;\n\t\t\twhile (end.next) end = end.next;\n\t\t\tend.next = runtime.HALT;\n\n\t\t\ttokens.requireToken(\"end\");\n\t\t} else {\n\t\t\tvar body = parser.requireElement(\"command\", tokens);\n\t\t}\n\t\tvar command = {\n\t\t\tbody: body,\n\t\t\top: function (context) {\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tbody.execute(context);\n\t\t\t\t});\n\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t},\n\t\t};\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"tell\", function (parser, runtime, tokens) {\n\t\tvar startToken = tokens.currentToken();\n\t\tif (!tokens.matchToken(\"tell\")) return;\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\tvar body = parser.requireElement(\"commandList\", tokens);\n\t\tif (tokens.hasMore() && !parser.featureStart(tokens.currentToken())) {\n\t\t\ttokens.requireToken(\"end\");\n\t\t}\n\t\tvar slot = \"tell_\" + startToken.start;\n\t\tvar tellCmd = {\n\t\t\tvalue: value,\n\t\t\tbody: body,\n\t\t\targs: [value],\n\t\t\tresolveNext: function (context) {\n\t\t\t\tvar iterator = context.meta.iterators[slot];\n\t\t\t\tif (iterator.index < iterator.value.length) {\n\t\t\t\t\tcontext.beingTold = iterator.value[iterator.index++];\n\t\t\t\t\treturn body;\n\t\t\t\t} else {\n\t\t\t\t\t// restore original me\n\t\t\t\t\tcontext.beingTold = iterator.originalBeingTold;\n\t\t\t\t\tif (this.next) {\n\t\t\t\t\t\treturn this.next;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn runtime.findNext(this.parent, context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\top: function (context, value) {\n\t\t\t\tif (value == null) {\n\t\t\t\t\tvalue = [];\n\t\t\t\t} else if (!(Array.isArray(value) || value instanceof NodeList)) {\n\t\t\t\t\tvalue = [value];\n\t\t\t\t}\n\t\t\t\tcontext.meta.iterators[slot] = {\n\t\t\t\t\toriginalBeingTold: context.beingTold,\n\t\t\t\t\tindex: 0,\n\t\t\t\t\tvalue: value,\n\t\t\t\t};\n\t\t\t\treturn this.resolveNext(context);\n\t\t\t},\n\t\t};\n\t\tparser.setParent(body, tellCmd);\n\t\treturn tellCmd;\n\t});\n\n\t_parser.addCommand(\"wait\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"wait\")) return;\n\t\tvar command;\n\n\t\t// wait on event\n\t\tif (tokens.matchToken(\"for\")) {\n\t\t\ttokens.matchToken(\"a\"); // optional \"a\"\n\t\t\tvar events = [];\n\t\t\tdo {\n\t\t\t\tvar lookahead = tokens.token(0);\n\t\t\t\tif (lookahead.type === 'NUMBER' || lookahead.type === 'L_PAREN') {\n\t\t\t\t\tevents.push({\n\t\t\t\t\t\ttime: parser.requireElement('timeExpression', tokens).evaluate() // TODO: do we want to allow async here?\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tevents.push({\n\t\t\t\t\t\tname: _parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\").evaluate(),\n\t\t\t\t\t\targs: parseEventArgs(tokens),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} while (tokens.matchToken(\"or\"));\n\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tvar on = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\n\t\t\t// wait on event\n\t\t\tcommand = {\n\t\t\t\tevent: events,\n\t\t\t\ton: on,\n\t\t\t\targs: [on],\n\t\t\t\top: function (context, on) {\n\t\t\t\t\tvar target = on ? on : context.me;\n\t\t\t\t\tif (!(target instanceof EventTarget))\n\t\t\t\t\t\tthrow new Error(\"Not a valid event target: \" + this.on.sourceFor());\n\t\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\t\tvar resolved = false;\n\t\t\t\t\t\tfor (const eventInfo of events) {\n\t\t\t\t\t\t\tvar listener = (event) => {\n\t\t\t\t\t\t\t\tcontext.result = event;\n\t\t\t\t\t\t\t\tfor (const arg of eventInfo.args) {\n\t\t\t\t\t\t\t\t\tcontext[arg.value] =\n\t\t\t\t\t\t\t\t\t\tevent[arg.value] || (event.detail ? event.detail[arg.value] : null);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!resolved) {\n\t\t\t\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t\t\t\t\tresolve(runtime.findNext(this, context));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (eventInfo.name) target.addEventListener(eventInfo.name, listener, { once: true });\n\t\t\t\t\t\t\telse if (eventInfo.time) setTimeout(listener, eventInfo.time, eventInfo.time)\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t} else {\n\t\t\tvar time;\n\t\t\tif (tokens.matchToken(\"a\")) {\n\t\t\t\ttokens.requireToken(\"tick\");\n\t\t\t\ttime = 0;\n\t\t\t} else {\n\t\t\t\ttime = _parser.requireElement(\"timeExpression\", tokens);\n\t\t\t}\n\n\t\t\tcommand = {\n\t\t\t\ttype: \"waitCmd\",\n\t\t\t\ttime: time,\n\t\t\t\targs: [time],\n\t\t\t\top: function (context, timeValue) {\n\t\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tresolve(runtime.findNext(this, context));\n\t\t\t\t\t\t}, timeValue);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t}\n\t});\n\n\t// TODO  - colon path needs to eventually become part of ruby-style symbols\n\t_parser.addGrammarElement(\"dotOrColonPath\", function (parser, runtime, tokens) {\n\t\tvar root = tokens.matchTokenType(\"IDENTIFIER\");\n\t\tif (root) {\n\t\t\tvar path = [root.value];\n\n\t\t\tvar separator = tokens.matchOpToken(\".\") || tokens.matchOpToken(\":\");\n\t\t\tif (separator) {\n\t\t\t\tdo {\n\t\t\t\t\tpath.push(tokens.requireTokenType(\"IDENTIFIER\").value);\n\t\t\t\t} while (tokens.matchOpToken(separator.value));\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttype: \"dotOrColonPath\",\n\t\t\t\tpath: path,\n\t\t\t\tevaluate: function () {\n\t\t\t\t\treturn path.join(separator ? separator.value : \"\");\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\n\t_parser.addGrammarElement(\"eventName\", function (parser, runtime, tokens) {\n\t\tvar token;\n\t\tif ((token = tokens.matchTokenType(\"STRING\"))) {\n\t\t\treturn {\n\t\t\t\tevaluate: function() {\n\t\t\t\t\treturn token.value;\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\treturn parser.parseElement(\"dotOrColonPath\", tokens);\n\t});\n\n\tfunction parseSendCmd(cmdType, parser, runtime, tokens) {\n\t\tvar eventName = parser.requireElement(\"eventName\", tokens);\n\n\t\tvar details = parser.parseElement(\"namedArgumentList\", tokens);\n\t\tif ((cmdType === \"send\" && tokens.matchToken(\"to\")) ||\n\t\t\t(cmdType === \"trigger\" && tokens.matchToken(\"on\"))) {\n\t\t\tvar to = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\tvar to = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t}\n\n\t\tvar sendCmd = {\n\t\t\teventName: eventName,\n\t\t\tdetails: details,\n\t\t\tto: to,\n\t\t\targs: [to, eventName, details],\n\t\t\top: function (context, to, eventName, details) {\n\t\t\t\truntime.forEach(to, function (target) {\n\t\t\t\t\truntime.triggerEvent(target, eventName, details ? details : {});\n\t\t\t\t});\n\t\t\t\treturn runtime.findNext(sendCmd, context);\n\t\t\t},\n\t\t};\n\t\treturn sendCmd;\n\t}\n\n\t_parser.addCommand(\"trigger\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"trigger\")) {\n\t\t\treturn parseSendCmd(\"trigger\", parser, runtime, tokens);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"send\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"send\")) {\n\t\t\treturn parseSendCmd(\"send\", parser, runtime, tokens);\n\t\t}\n\t});\n\n\tvar parseReturnFunction = function (parser, runtime, tokens, returnAValue) {\n\t\tif (returnAValue) {\n\t\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\t}\n\n\t\tvar returnCmd = {\n\t\t\tvalue: value,\n\t\t\targs: [value],\n\t\t\top: function (context, value) {\n\t\t\t\tvar resolve = context.meta.resolve;\n\t\t\t\tcontext.meta.returned = true;\n\t\t\t\tif (resolve) {\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontext.meta.returned = true;\n\t\t\t\t\tcontext.meta.returnValue = value;\n\t\t\t\t}\n\t\t\t\treturn runtime.HALT;\n\t\t\t},\n\t\t};\n\t\treturn returnCmd;\n\t};\n\n\t_parser.addCommand(\"return\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"return\")) {\n\t\t\treturn parseReturnFunction(parser, runtime, tokens, true);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"exit\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"exit\")) {\n\t\t\treturn parseReturnFunction(parser, runtime, tokens, false);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"halt\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"halt\")) {\n\t\t\tif (tokens.matchToken(\"the\")) {\n\t\t\t\ttokens.requireToken(\"event\");\n\t\t\t\t// optional possessive\n\t\t\t\tif (tokens.matchOpToken(\"'\")) {\n\t\t\t\t\ttokens.requireToken(\"s\");\n\t\t\t\t}\n\t\t\t\tvar keepExecuting = true;\n\t\t\t}\n\t\t\tif (tokens.matchToken(\"bubbling\")) {\n\t\t\t\tvar bubbling = true;\n\t\t\t} else if (tokens.matchToken(\"default\")) {\n\t\t\t\tvar haltDefault = true;\n\t\t\t}\n\t\t\tvar exit = parseReturnFunction(parser, runtime, tokens, false);\n\n\t\t\tvar haltCmd = {\n\t\t\t\tkeepExecuting: true,\n\t\t\t\tbubbling: bubbling,\n\t\t\t\thaltDefault: haltDefault,\n\t\t\t\texit: exit,\n\t\t\t\top: function (ctx) {\n\t\t\t\t\tif (ctx.event) {\n\t\t\t\t\t\tif (bubbling) {\n\t\t\t\t\t\t\tctx.event.stopPropagation();\n\t\t\t\t\t\t} else if (haltDefault) {\n\t\t\t\t\t\t\tctx.event.preventDefault();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.event.stopPropagation();\n\t\t\t\t\t\t\tctx.event.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (keepExecuting) {\n\t\t\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn haltCmd;\n\t\t}\n\t});\n\n\t_parser.addCommand(\"log\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"log\")) return;\n\t\tvar exprs = [parser.parseElement(\"expression\", tokens)];\n\t\twhile (tokens.matchOpToken(\",\")) {\n\t\t\texprs.push(parser.requireElement(\"expression\", tokens));\n\t\t}\n\t\tif (tokens.matchToken(\"with\")) {\n\t\t\tvar withExpr = parser.requireElement(\"expression\", tokens);\n\t\t}\n\t\tvar logCmd = {\n\t\t\texprs: exprs,\n\t\t\twithExpr: withExpr,\n\t\t\targs: [withExpr, exprs],\n\t\t\top: function (ctx, withExpr, values) {\n\t\t\t\tif (withExpr) {\n\t\t\t\t\twithExpr.apply(null, values);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log.apply(null, values);\n\t\t\t\t}\n\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t},\n\t\t};\n\t\treturn logCmd;\n\t});\n\n\t_parser.addCommand(\"throw\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"throw\")) return;\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\tvar throwCmd = {\n\t\t\texpr: expr,\n\t\t\targs: [expr],\n\t\t\top: function (ctx, expr) {\n\t\t\t\truntime.registerHyperTrace(ctx, expr);\n\t\t\t\tvar reject = ctx.meta && ctx.meta.reject;\n\t\t\t\tif (reject) {\n\t\t\t\t\treject(expr);\n\t\t\t\t\treturn runtime.HALT;\n\t\t\t\t} else {\n\t\t\t\t\tthrow expr;\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\treturn throwCmd;\n\t});\n\n\tvar parseCallOrGet = function (parser, runtime, tokens) {\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\tvar callCmd = {\n\t\t\texpr: expr,\n\t\t\targs: [expr],\n\t\t\top: function (context, result) {\n\t\t\t\tcontext.result = result;\n\t\t\t\treturn runtime.findNext(callCmd, context);\n\t\t\t},\n\t\t};\n\t\treturn callCmd;\n\t};\n\t_parser.addCommand(\"call\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"call\")) return;\n\t\tvar call = parseCallOrGet(parser, runtime, tokens);\n\t\tif (call.expr && call.expr.type !== \"functionCall\") {\n\t\t\tparser.raiseParseError(tokens, \"Must be a function invocation\");\n\t\t}\n\t\treturn call;\n\t});\n\t_parser.addCommand(\"get\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"get\")) {\n\t\t\treturn parseCallOrGet(parser, runtime, tokens);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"make\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"make\")) return;\n\t\ttokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\n\t\tvar args = [];\n\t\tif (expr.type !== \"queryRef\" && tokens.matchToken(\"from\")) {\n\t\t\tdo {\n\t\t\t\targs.push(parser.requireElement(\"expression\", tokens));\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t}\n\n\t\tif (tokens.matchToken(\"called\")) {\n\t\t\tvar name = tokens.requireTokenType(\"IDENTIFIER\").value;\n\t\t}\n\n\t\tvar command;\n\t\tif (expr.type === \"queryRef\") {\n\t\t\tcommand = {\n\t\t\t\top: function (ctx) {\n\t\t\t\t\tvar match,\n\t\t\t\t\t\ttagname = \"div\",\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tclasses = [];\n\t\t\t\t\tvar re = /(?:(^|#|\\.)([^#\\. ]+))/g;\n\t\t\t\t\twhile ((match = re.exec(expr.css))) {\n\t\t\t\t\t\tif (match[1] === \"\") tagname = match[2].trim();\n\t\t\t\t\t\telse if (match[1] === \"#\") id = match[2].trim();\n\t\t\t\t\t\telse classes.push(match[2].trim());\n\t\t\t\t\t}\n\n\t\t\t\t\tvar result = document.createElement(tagname);\n\t\t\t\t\tif (id !== undefined) result.id = id;\n\t\t\t\t\tfor (var i = 0; i < classes.length; i++) {\n\t\t\t\t\t\tvar cls = classes[i];\n\t\t\t\t\t\tresult.classList.add(cls)\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.result = result;\n\t\t\t\t\tif (name) ctx[name] = result;\n\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t} else {\n\t\t\tcommand = {\n\t\t\t\targs: [expr, args],\n\t\t\t\top: function (ctx, expr, args) {\n\t\t\t\t\tctx.result = varargConstructor(expr, args);\n\t\t\t\t\tif (name) ctx[name] = ctx.result;\n\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"pseudoCommand\", function (parser, runtime, tokens) {\n\n\t\ttry {\n\t\t\tvar expr = parser.requireElement(\"primaryExpression\", tokens);\n\t\t} finally {\n\t\t\ttokens.popFollow();\n\t\t}\n\t\tif (expr.type !== \"functionCall\" && expr.root.type !== \"symbol\" && expr.root.root != null) {\n\t\t\tparser.raiseParseError(tokens, \"Implicit function calls must start with a simple function\");\n\t\t}\n\n\t\tvar functionName = expr.root.name;\n\n\t\tif (tokens.matchAnyToken(\"the\", \"to\", \"on\", \"with\", \"into\", \"from\", \"at\")) {\n\t\t\tvar target = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"me\")) {\n\t\t\tvar target = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t}\n\t\tvar functionArgs = expr.argExressions;\n\n\t\t/** @type {GrammarElement} */\n\t\tvar pseudoCommand = {\n\t\t\ttype: \"pseudoCommand\",\n\t\t\texpr: expr,\n\t\t\targs: [target, functionArgs],\n\t\t\top: function (context, target, args) {\n\t\t\t\tif (target) {\n\t\t\t\t\tvar func = target[functionName];\n\t\t\t\t} else {\n\t\t\t\t\tvar func = runtime.resolveSymbol(functionName, context);\n\t\t\t\t}\n\t\t\t\tif (func.hyperfunc) {\n\t\t\t\t\targs.push(context);\n\t\t\t\t}\n\t\t\t\tvar result = func.apply(target, args);\n\t\t\t\tcontext.result = result;\n\t\t\t\treturn runtime.findNext(pseudoCommand, context);\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t},\n\t\t};\n\n\t\treturn pseudoCommand;\n\t});\n\n\t/**\n\t* @param {ParserObject} parser\n\t* @param {RuntimeObject} runtime\n\t* @param {TokensObject} tokens\n\t* @param {*} target\n\t* @param {*} value\n\t* @returns\n\t*/\n\tvar makeSetter = function (parser, runtime, tokens, target, value) {\n\t\tvar symbolWrite = target.type === \"symbol\";\n\t\tvar attributeWrite = target.type === \"attributeRef\";\n\t\tif (!attributeWrite && !symbolWrite && target.root == null) {\n\t\t\tparser.raiseParseError(tokens, \"Can only put directly into symbols, not references\");\n\t\t}\n\n\t\tvar root = null;\n\t\tvar prop = null;\n\t\tif (symbolWrite) {\n\t\t\t// root is null\n\t\t} else if (attributeWrite) {\n\t\t\troot = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\tvar attribute = target;\n\t\t} else {\n\t\t\tprop = target.prop ? target.prop.value : null;\n\t\t\tvar attribute = target.attribute;\n\t\t\troot = target.root;\n\t\t}\n\n\t\t/** @type {GrammarElement} */\n\t\tvar setCmd = {\n\t\t\ttarget: target,\n\t\t\tsymbolWrite: symbolWrite,\n\t\t\tvalue: value,\n\t\t\targs: [root, value],\n\t\t\top: function (context, root, valueToSet) {\n\t\t\t\tif (symbolWrite) {\n\t\t\t\t\truntime.setSymbol(target.name, context, target.symbolType, valueToSet);\n\t\t\t\t} else {\n\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\tif (attribute) {\n\t\t\t\t\t\t\tif (valueToSet == null) {\n\t\t\t\t\t\t\t\telt.removeAttribute(attribute.name);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\telt.setAttribute(attribute.name, valueToSet);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telt[prop] = valueToSet;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t},\n\t\t};\n\t\treturn setCmd;\n\t};\n\n\t_parser.addCommand(\"default\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"default\")) return;\n\t\tvar target = parser.requireElement(\"assignableExpression\", tokens);\n\t\ttokens.requireToken(\"to\");\n\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\n\t\t/** @type {GrammarElement} */\n\t\tvar setter = makeSetter(parser, runtime, tokens, target, value);\n\t\tvar defaultCmd = {\n\t\t\ttarget: target,\n\t\t\tvalue: value,\n\t\t\tsetter: setter,\n\t\t\targs: [target],\n\t\t\top: function (context, target) {\n\t\t\t\tif (target) {\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t} else {\n\t\t\t\t\treturn setter;\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\tsetter.parent = defaultCmd;\n\t\treturn defaultCmd;\n\t});\n\n\t_parser.addCommand(\"set\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"set\")) return;\n\t\tif (tokens.currentToken().type === \"L_BRACE\") {\n\t\t\tvar obj = parser.requireElement(\"objectLiteral\", tokens);\n\t\t\ttokens.requireToken(\"on\");\n\t\t\tvar target = parser.requireElement(\"expression\", tokens);\n\n\t\t\tvar command = {\n\t\t\t\tobjectLiteral: obj,\n\t\t\t\ttarget: target,\n\t\t\t\targs: [obj, target],\n\t\t\t\top: function (ctx, obj, target) {\n\t\t\t\t\tmergeObjects(target, obj);\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t}\n\n\t\ttry {\n\t\t\ttokens.pushFollow(\"to\");\n\t\t\tvar target = parser.requireElement(\"assignableExpression\", tokens);\n\t\t} finally {\n\t\t\ttokens.popFollow();\n\t\t}\n\t\ttokens.requireToken(\"to\");\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\treturn makeSetter(parser, runtime, tokens, target, value);\n\t});\n\n\t_parser.addCommand(\"if\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"if\")) return;\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\ttokens.matchToken(\"then\"); // optional 'then'\n\t\tvar trueBranch = parser.parseElement(\"commandList\", tokens);\n\t\tif (tokens.matchToken(\"else\")) {\n\t\t\tvar falseBranch = parser.parseElement(\"commandList\", tokens);\n\t\t}\n\t\tif (tokens.hasMore()) {\n\t\t\ttokens.requireToken(\"end\");\n\t\t}\n\n\t\t/** @type {GrammarElement} */\n\t\tvar ifCmd = {\n\t\t\texpr: expr,\n\t\t\ttrueBranch: trueBranch,\n\t\t\tfalseBranch: falseBranch,\n\t\t\targs: [expr],\n\t\t\top: function (context, exprValue) {\n\t\t\t\tif (exprValue) {\n\t\t\t\t\treturn trueBranch;\n\t\t\t\t} else if (falseBranch) {\n\t\t\t\t\treturn falseBranch;\n\t\t\t\t} else {\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\tparser.setParent(trueBranch, ifCmd);\n\t\tparser.setParent(falseBranch, ifCmd);\n\t\treturn ifCmd;\n\t});\n\n\tvar parseRepeatExpression = function (parser, tokens, runtime, startedWithForToken) {\n\t\tvar innerStartToken = tokens.currentToken();\n\t\tvar identifier;\n\t\tif (tokens.matchToken(\"for\") || startedWithForToken) {\n\t\t\tvar identifierToken = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\tidentifier = identifierToken.value;\n\t\t\ttokens.requireToken(\"in\");\n\t\t\tvar expression = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"in\")) {\n\t\t\tidentifier = \"it\";\n\t\t\tvar expression = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"while\")) {\n\t\t\tvar whileExpr = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"until\")) {\n\t\t\tvar isUntil = true;\n\t\t\tif (tokens.matchToken(\"event\")) {\n\t\t\t\tvar evt = _parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\");\n\t\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\t\tvar on = parser.requireElement(\"expression\", tokens);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar whileExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\t\t} else if (tokens.matchTokenType(\"NUMBER\")) {\n\t\t\tvar times = parseFloat(innerStartToken.value);\n\t\t\ttokens.requireToken(\"times\");\n\t\t} else {\n\t\t\ttokens.matchToken(\"forever\"); // consume optional forever\n\t\t\tvar forever = true;\n\t\t}\n\n\t\tif (tokens.matchToken(\"index\")) {\n\t\t\tvar identifierToken = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\tvar indexIdentifier = identifierToken.value;\n\t\t}\n\n\t\tvar loop = parser.parseElement(\"commandList\", tokens);\n\t\tif (loop && evt) {\n\t\t\t// if this is an event based loop, wait a tick at the end of the loop so that\n\t\t\t// events have a chance to trigger in the loop condition o_O)))\n\t\t\tvar last = loop;\n\t\t\twhile (last.next) {\n\t\t\t\tlast = last.next;\n\t\t\t}\n\t\t\tvar waitATick = {\n\t\t\t\ttype: \"waitATick\",\n\t\t\t\top: function () {\n\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tresolve(runtime.findNext(waitATick));\n\t\t\t\t\t\t}, 0);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t};\n\t\t\tlast.next = waitATick;\n\t\t}\n\t\tif (tokens.hasMore()) {\n\t\t\ttokens.requireToken(\"end\");\n\t\t}\n\n\t\tif (identifier == null) {\n\t\t\tidentifier = \"_implicit_repeat_\" + innerStartToken.start;\n\t\t\tvar slot = identifier;\n\t\t} else {\n\t\t\tvar slot = identifier + \"_\" + innerStartToken.start;\n\t\t}\n\n\t\tvar repeatCmd = {\n\t\t\tidentifier: identifier,\n\t\t\tindexIdentifier: indexIdentifier,\n\t\t\tslot: slot,\n\t\t\texpression: expression,\n\t\t\tforever: forever,\n\t\t\ttimes: times,\n\t\t\tuntil: isUntil,\n\t\t\tevent: evt,\n\t\t\ton: on,\n\t\t\twhileExpr: whileExpr,\n\t\t\tresolveNext: function () {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tloop: loop,\n\t\t\targs: [whileExpr],\n\t\t\top: function (context, whileValue) {\n\t\t\t\tvar iteratorInfo = context.meta.iterators[slot];\n\t\t\t\tvar keepLooping = false;\n\t\t\t\tvar loopVal = null;\n\t\t\t\tif (this.forever) {\n\t\t\t\t\tkeepLooping = true;\n\t\t\t\t} else if (this.until) {\n\t\t\t\t\tif (evt) {\n\t\t\t\t\t\tkeepLooping = context.meta.iterators[slot].eventFired === false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkeepLooping = whileValue !== true;\n\t\t\t\t\t}\n\t\t\t\t} else if (whileExpr) {\n\t\t\t\t\tkeepLooping = whileValue;\n\t\t\t\t} else if (times) {\n\t\t\t\t\tkeepLooping = iteratorInfo.index < this.times;\n\t\t\t\t} else {\n\t\t\t\t\tvar nextValFromIterator = iteratorInfo.iterator.next();\n\t\t\t\t\tkeepLooping = !nextValFromIterator.done;\n\t\t\t\t\tloopVal = nextValFromIterator.value;\n\t\t\t\t}\n\n\t\t\t\tif (keepLooping) {\n\t\t\t\t\tif (iteratorInfo.value) {\n\t\t\t\t\t\tcontext.result = context[identifier] = loopVal;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.result = iteratorInfo.index;\n\t\t\t\t\t}\n\t\t\t\t\tif (indexIdentifier) {\n\t\t\t\t\t\tcontext[indexIdentifier] = iteratorInfo.index;\n\t\t\t\t\t}\n\t\t\t\t\titeratorInfo.index++;\n\t\t\t\t\treturn loop;\n\t\t\t\t} else {\n\t\t\t\t\tcontext.meta.iterators[slot] = null;\n\t\t\t\t\treturn runtime.findNext(this.parent, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\tparser.setParent(loop, repeatCmd);\n\t\tvar repeatInit = {\n\t\t\tname: \"repeatInit\",\n\t\t\targs: [expression, evt, on],\n\t\t\top: function (context, value, event, on) {\n\t\t\t\tvar iteratorInfo = {\n\t\t\t\t\tindex: 0,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\teventFired: false,\n\t\t\t\t};\n\t\t\t\tcontext.meta.iterators[slot] = iteratorInfo;\n\t\t\t\tif (value && value[Symbol.iterator]) {\n\t\t\t\t\titeratorInfo.iterator = value[Symbol.iterator]();\n\t\t\t\t}\n\t\t\t\tif (evt) {\n\t\t\t\t\tvar target = on || context.me;\n\t\t\t\t\ttarget.addEventListener(\n\t\t\t\t\t\tevent,\n\t\t\t\t\t\tfunction (e) {\n\t\t\t\t\t\t\tcontext.meta.iterators[slot].eventFired = true;\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn repeatCmd; // continue to loop\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t},\n\t\t};\n\t\tparser.setParent(repeatCmd, repeatInit);\n\t\treturn repeatInit;\n\t};\n\n\t_parser.addCommand(\"repeat\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"repeat\")) {\n\t\t\treturn parseRepeatExpression(parser, tokens, runtime, false);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"for\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"for\")) {\n\t\t\treturn parseRepeatExpression(parser, tokens, runtime, true);\n\t\t}\n\t});\n\n  _parser.addCommand(\"continue\", function (parser, runtime, tokens) {\n\n    if (!tokens.matchToken(\"continue\")) return;\n\n    var command = {\n      op: function (context) {\n\n        // scan for the closest repeat statement\n        for (var parent = this.parent ; true ; parent = parent.parent) {\n\n          if (parent == undefined) {\n            parser.raiseParseError(tokens, \"Command `continue` cannot be used outside of a `repeat` loop.\")\n          }\n          if (parent.loop != undefined) {\n            return parent.resolveNext(context)\n          }\n        }\n      }\n    };\n    return command;\n  });\n\n\t_parser.addGrammarElement(\"stringLike\", function (parser, runtime, tokens) {\n\t\treturn _parser.parseAnyOf([\"string\", \"nakedString\"], tokens);\n\t});\n\n\t_parser.addCommand(\"append\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"append\")) return;\n\t\tvar target = null;\n\t\tvar prop = null;\n\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\n\t\tif (tokens.matchToken(\"to\")) {\n\t\t\ttarget = parser.requireElement(\"expression\", tokens);\n\t\t}\n\n\t\tif (target == null) {\n\t\t\tprop = \"result\";\n\t\t} else if (target.type === \"symbol\") {\n\t\t\tprop = target.name;\n\t\t} else if (target.type === \"propertyAccess\") {\n\t\t\tprop = target.prop.value;\n\t\t} else {\n\t\t\tthrow \"Unable to append to \" + target.type;\n\t\t}\n\n\t\tvar command = {\n\t\t\tvalue: value,\n\t\t\ttarget: target,\n\t\t\targs: [value],\n\t\t\top: function (context, value) {\n\t\t\t\tif (Array.isArray(context[prop])) {\n\t\t\t\t\tcontext[prop].push(value);\n\t\t\t\t} else if (context[prop] instanceof Element) {\n\t\t\t\t\tif (typeof value == \"string\") {\n\t\t\t\t\t\tcontext[prop].innerHTML += value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow \"Don't know how to append non-strings to an HTML Element yet.\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontext[prop] += value;\n\t\t\t\t}\n\n\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\treturn runtime.unifiedExec(this, context/*, value, target*/);\n\t\t\t},\n\t\t};\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"increment\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"increment\")) return;\n\t\tvar amount;\n\n\t\t// This is optional.  Defaults to \"result\"\n\t\tvar target = parser.parseElement(\"assignableExpression\", tokens);\n\n\t\t// This is optional. Defaults to 1.\n\t\tif (tokens.matchToken(\"by\")) {\n\t\t\tamount = parser.requireElement(\"expression\", tokens);\n\t\t}\n\n\t\tvar command = {\n\t\t\ttarget: target,\n\t\t\targs: [target, amount],\n\t\t\top: function (context, targetValue, amount) {\n\t\t\t\ttargetValue = targetValue ? parseFloat(targetValue) : 0;\n\t\t\t\tamount = amount ? parseFloat(amount) : 1;\n\t\t\t\tvar newValue = targetValue + amount;\n\t\t\t\tvar setter = makeSetter(parser, runtime, tokens, target, newValue);\n\t\t\t\tcontext.result = newValue;\n\t\t\t\tsetter.parent = this;\n\t\t\t\treturn setter;\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\treturn runtime.unifiedExec(this, context/* , target, amount */);\n\t\t\t},\n\t\t};\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"decrement\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"decrement\")) return;\n\t\tvar amount;\n\n\t\t// This is optional.  Defaults to \"result\"\n\t\tvar target = parser.parseElement(\"assignableExpression\", tokens);\n\n\t\t// This is optional. Defaults to 1.\n\t\tif (tokens.matchToken(\"by\")) {\n\t\t\tamount = parser.requireElement(\"expression\", tokens);\n\t\t}\n\n\t\tvar command = {\n\t\t\ttarget: target,\n\t\t\targs: [target, amount],\n\t\t\top: function (context, targetValue, amount) {\n\t\t\t\ttargetValue = targetValue ? parseFloat(targetValue) : 0;\n\t\t\t\tamount = amount ? parseFloat(amount) : 1;\n\t\t\t\tvar newValue = targetValue - amount;\n\t\t\t\tvar setter = makeSetter(parser, runtime, tokens, target, newValue);\n\t\t\t\tcontext.result = newValue;\n\t\t\t\tsetter.parent = this;\n\t\t\t\treturn setter;\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\treturn runtime.unifiedExec(this, context/*, target, amount*/);\n\t\t\t},\n\t\t};\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"fetch\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"fetch\")) return;\n\t\tvar url = parser.requireElement(\"stringLike\", tokens);\n\n\t\tif (tokens.matchToken(\"with\")) {\n\t\t\tvar args = parser.parseElement(\"nakedNamedArgumentList\", tokens);\n\t\t} else {\n\t\t\tvar args = parser.parseElement(\"objectLiteral\", tokens);\n\t\t}\n\n\t\tvar type = \"text\";\n\t\tvar conversion;\n\t\tif (tokens.matchToken(\"as\")) {\n\t\t\ttokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n\t\t\tif (tokens.matchToken(\"json\") || tokens.matchToken(\"Object\")) {\n\t\t\t\ttype = \"json\";\n\t\t\t} else if (tokens.matchToken(\"response\")) {\n\t\t\t\ttype = \"response\";\n\t\t\t} else if (tokens.matchToken(\"html\")) {\n\t\t\t\ttype = \"html\";\n\t\t\t} else if (tokens.matchToken(\"text\")) {\n\t\t\t\t// default, ignore\n\t\t\t} else {\n\t\t\t\tconversion = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n\t\t\t}\n\t\t}\n\n\t\t/** @type {GrammarElement} */\n\t\tvar fetchCmd = {\n\t\t\turl: url,\n\t\t\targExpressions: args,\n\t\t\targs: [url, args],\n\t\t\top: function (context, url, args) {\n\t\t\t\tvar detail = args || {};\n\t\t\t\tdetail[\"sentBy\"] = context.me;\n\t\t\t\truntime.triggerEvent(context.me, \"hyperscript:beforeFetch\", detail);\n\t\t\t\targs = detail;\n\t\t\t\treturn fetch(url, args)\n\t\t\t\t\t.then(function (resp) {\n\t\t\t\t\t\tif (type === \"response\") {\n\t\t\t\t\t\t\tcontext.result = resp;\n\t\t\t\t\t\t\treturn runtime.findNext(fetchCmd, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (type === \"json\") {\n\t\t\t\t\t\t\treturn resp.json().then(function (result) {\n\t\t\t\t\t\t\t\tcontext.result = result;\n\t\t\t\t\t\t\t\treturn runtime.findNext(fetchCmd, context);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn resp.text().then(function (result) {\n\t\t\t\t\t\t\tif (conversion) result = runtime.convertValue(result, conversion);\n\n\t\t\t\t\t\t\tif (type === \"html\") result = runtime.convertValue(result, \"Fragment\");\n\n\t\t\t\t\t\t\tcontext.result = result;\n\t\t\t\t\t\t\treturn runtime.findNext(fetchCmd, context);\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t\t.catch(function (reason) {\n\t\t\t\t\t\truntime.triggerEvent(context.me, \"fetch:error\", {\n\t\t\t\t\t\t\treason: reason,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t});\n\t\t\t},\n\t\t};\n\t\treturn fetchCmd;\n\t});\n}\n\n//====================================================================\n// Initialization\n//====================================================================\nfunction ready(fn) {\n\tif (document.readyState !== \"loading\") {\n\t\tsetTimeout(fn);\n\t} else {\n\t\tdocument.addEventListener(\"DOMContentLoaded\", fn);\n\t}\n}\n\nfunction getMetaConfig() {\n\t/** @type {HTMLMetaElement} */\n\tvar element = document.querySelector('meta[name=\"htmx-config\"]');\n\tif (element) {\n\t\treturn parseJSON(element.content);\n\t} else {\n\t\treturn null;\n\t}\n}\n\nfunction mergeMetaConfig() {\n\tvar metaConfig = getMetaConfig();\n\tif (metaConfig) {\n\t\t_hyperscript.config = mergeObjects(_hyperscript.config, metaConfig);\n\t}\n}\n\nif (\"document\" in globalScope) {\n\t/** @type {HTMLScriptElement[]} */\n\tvar scripts = Array.from(document.querySelectorAll(\"script[type='text/hyperscript'][src]\"))\n\tPromise.all(\n\t\tscripts.map(function (script) {\n\t\t\treturn fetch(script.src)\n\t\t\t\t.then(function (res) {\n\t\t\t\t\treturn res.text();\n\t\t\t\t})\n\t\t\t\t.then(function (code) {\n\t\t\t\t\treturn _runtime.evaluate(code);\n\t\t\t\t});\n\t\t})\n\t).then(function () {\n\t\tready(function () {\n\t\t\tmergeMetaConfig();\n\t\t\t_runtime.processNode(document.documentElement);\n\t\t\tdocument.addEventListener(\"htmx:load\", function (/** @type {CustomEvent} */ evt) {\n\t\t\t\t_runtime.processNode(evt.detail.elt);\n\t\t\t});\n\t\t});\n\t});\n}\n\n//====================================================================\n// API\n//====================================================================\n/** @type {HyperscriptObject} */\nexport default _hyperscript = mergeObjects(\n\tfunction (str, ctx) {\n\t\treturn _runtime.evaluate(str, ctx); //OK\n\t},\n\t{\n\t\tinternals: {\n\t\t\tlexer: _lexer,\n\t\t\tparser: _parser,\n\t\t\truntime: _runtime,\n\t\t},\n\t\tElementCollection: ElementCollection,\n\t\taddFeature: function (keyword, definition) {\n\t\t\t_parser.addFeature(keyword, definition);\n\t\t},\n\t\taddCommand: function (keyword, definition) {\n\t\t\t_parser.addCommand(keyword, definition);\n\t\t},\n\t\taddLeafExpression: function (name, definition) {\n\t\t\t_parser.addLeafExpression(name, definition);\n\t\t},\n\t\taddIndirectExpression: function (name, definition) {\n\t\t\t_parser.addIndirectExpression(name, definition);\n\t\t},\n\t\tevaluate: _runtime.evaluate.bind(_runtime),\n\t\tparse: _runtime.parse.bind(_runtime),\n\t\tprocessNode: _runtime.processNode.bind(_runtime),\n\t\tconfig: {\n\t\t\tattributes: \"_, script, data-script\",\n\t\t\tdefaultTransition: \"all 500ms ease-in\",\n\t\t\tdisableSelector: \"[disable-scripting], [data-disable-scripting]\",\n\t\t\tconversions: CONVERSIONS,\n\t\t},\n\t}\n);\n","///=========================================================================\n/// This module provides the core web functionality for hyperscript\n///=========================================================================\n\nimport { mergeObjects } from \"./utils.js\"\n\n/**\n * @param {HyperscriptObject} _hyperscript\n */\nexport default _hyperscript => {\n\t_hyperscript.addCommand(\"settle\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"settle\")) {\n\t\t\tif (!parser.commandBoundary(tokens.currentToken())) {\n\t\t\t\tvar on = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar on = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tvar settleCommand = {\n\t\t\t\ttype: \"settleCmd\",\n\t\t\t\targs: [on],\n\t\t\t\top: function (context, on) {\n\t\t\t\t\tvar resolve = null;\n\t\t\t\t\tvar resolved = false;\n\t\t\t\t\tvar transitionStarted = false;\n\n\t\t\t\t\tvar promise = new Promise(function (r) {\n\t\t\t\t\t\tresolve = r;\n\t\t\t\t\t});\n\n\t\t\t\t\t// listen for a transition begin\n\t\t\t\t\ton.addEventListener(\n\t\t\t\t\t\t\"transitionstart\",\n\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\ttransitionStarted = true;\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t);\n\n\t\t\t\t\t// if no transition begins in 500ms, cancel\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tif (!transitionStarted && !resolved) {\n\t\t\t\t\t\t\tresolve(runtime.findNext(settleCommand, context));\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 500);\n\n\t\t\t\t\t// continue on a transition emd\n\t\t\t\t\ton.addEventListener(\n\t\t\t\t\t\t\"transitionend\",\n\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\tif (!resolved) {\n\t\t\t\t\t\t\t\tresolve(runtime.findNext(settleCommand, context));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t);\n\t\t\t\t\treturn promise;\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn settleCommand;\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"add\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"add\")) {\n\t\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\t\tvar attributeRef = null;\n\t\t\tvar cssDeclaration = null;\n\t\t\tif (classRef == null) {\n\t\t\t\tattributeRef = parser.parseElement(\"attributeRef\", tokens);\n\t\t\t\tif (attributeRef == null) {\n\t\t\t\t\tcssDeclaration = parser.parseElement(\"styleLiteral\", tokens);\n\t\t\t\t\tif (cssDeclaration == null) {\n\t\t\t\t\t\tparser.raiseParseError(tokens, \"Expected either a class reference or attribute expression\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar classRefs = [classRef];\n\t\t\t\twhile ((classRef = parser.parseElement(\"classRef\", tokens))) {\n\t\t\t\t\tclassRefs.push(classRef);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"to\")) {\n\t\t\t\tvar to = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar to = parser.parseElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tif (classRefs) {\n\t\t\t\treturn {\n\t\t\t\t\tclassRefs: classRefs,\n\t\t\t\t\tto: to,\n\t\t\t\t\targs: [to, classRefs],\n\t\t\t\t\top: function (context, to, classRefs) {\n\t\t\t\t\t\truntime.forEach(classRefs, function (classRef) {\n\t\t\t\t\t\t\truntime.implicitLoop(to, function (target) {\n\t\t\t\t\t\t\t\tif (target instanceof Element) target.classList.add(classRef.className);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t} else if (attributeRef) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"addCmd\",\n\t\t\t\t\tattributeRef: attributeRef,\n\t\t\t\t\tto: to,\n\t\t\t\t\targs: [to],\n\t\t\t\t\top: function (context, to, attrRef) {\n\t\t\t\t\t\truntime.implicitLoop(to, function (target) {\n\t\t\t\t\t\t\ttarget.setAttribute(attributeRef.name, attributeRef.value);\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t\t},\n\t\t\t\t\texecute: function (ctx) {\n\t\t\t\t\t\treturn runtime.unifiedExec(this, ctx);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"addCmd\",\n\t\t\t\t\tcssDeclaration: cssDeclaration,\n\t\t\t\t\tto: to,\n\t\t\t\t\targs: [to, cssDeclaration],\n\t\t\t\t\top: function (context, to, css) {\n\t\t\t\t\t\truntime.implicitLoop(to, function (target) {\n\t\t\t\t\t\t\ttarget.style.cssText += css;\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t\t},\n\t\t\t\t\texecute: function (ctx) {\n\t\t\t\t\t\treturn runtime.unifiedExec(this, ctx);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t});\n\n\t_hyperscript.internals.parser.addGrammarElement(\"styleLiteral\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"{\")) return;\n\n\t\tvar stringParts = [\"\"]\n\t\tvar exprs = []\n\n\t\twhile (tokens.hasMore()) {\n\t\t\tif (tokens.matchOpToken(\"\\\\\")) {\n\t\t\t\ttokens.consumeToken();\n\t\t\t} else if (tokens.matchOpToken(\"}\")) {\n\t\t\t\tbreak;\n\t\t\t} else if (tokens.matchToken(\"$\")) {\n\t\t\t\tvar opencurly = tokens.matchOpToken(\"{\");\n\t\t\t\tvar expr = parser.parseElement(\"expression\", tokens);\n\t\t\t\tif (opencurly) tokens.requireOpToken(\"}\");\n\n\t\t\t\texprs.push(expr)\n\t\t\t\tstringParts.push(\"\")\n\t\t\t} else {\n\t\t\t\tvar tok = tokens.consumeToken();\n\t\t\t\tstringParts[stringParts.length-1] += tokens.source.substring(tok.start, tok.end);\n\t\t\t}\n\n\t\t\tstringParts[stringParts.length-1] += tokens.lastWhitespace();\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"styleLiteral\",\n\t\t\targs: [exprs],\n\t\t\top: function (ctx, exprs) {\n\t\t\t\tvar rv = \"\";\n\n\t\t\t\tstringParts.forEach(function (part, idx) {\n\t\t\t\t\trv += part;\n\t\t\t\t\tif (idx in exprs) rv += exprs[idx];\n\t\t\t\t});\n\n\t\t\t\treturn rv;\n\t\t\t},\n\t\t\tevaluate: function(ctx) {\n\t\t\t\treturn runtime.unifiedEval(this, ctx);\n\t\t\t}\n\t\t}\n\t})\n\n\t_hyperscript.addCommand(\"remove\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"remove\")) {\n\t\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\t\tvar attributeRef = null;\n\t\t\tvar elementExpr = null;\n\t\t\tif (classRef == null) {\n\t\t\t\tattributeRef = parser.parseElement(\"attributeRef\", tokens);\n\t\t\t\tif (attributeRef == null) {\n\t\t\t\t\telementExpr = parser.parseElement(\"expression\", tokens);\n\t\t\t\t\tif (elementExpr == null) {\n\t\t\t\t\t\tparser.raiseParseError(\n\t\t\t\t\t\t\ttokens,\n\t\t\t\t\t\t\t\"Expected either a class reference, attribute expression or value expression\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar classRefs = [classRef];\n\t\t\t\twhile ((classRef = parser.parseElement(\"classRef\", tokens))) {\n\t\t\t\t\tclassRefs.push(classRef);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tvar from = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar from = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tif (elementExpr) {\n\t\t\t\treturn {\n\t\t\t\t\telementExpr: elementExpr,\n\t\t\t\t\tfrom: from,\n\t\t\t\t\targs: [elementExpr],\n\t\t\t\t\top: function (context, element) {\n\t\t\t\t\t\truntime.implicitLoop(element, function (target) {\n\t\t\t\t\t\t\tif (target.parentElement) {\n\t\t\t\t\t\t\t\ttarget.parentElement.removeChild(target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tclassRefs: classRefs,\n\t\t\t\t\tattributeRef: attributeRef,\n\t\t\t\t\telementExpr: elementExpr,\n\t\t\t\t\tfrom: from,\n\t\t\t\t\targs: [classRefs, from],\n\t\t\t\t\top: function (context, classRefs, from) {\n\t\t\t\t\t\tif (classRefs) {\n\t\t\t\t\t\t\truntime.forEach(classRefs, function (classRef) {\n\t\t\t\t\t\t\t\truntime.implicitLoop(from, function (target) {\n\t\t\t\t\t\t\t\t\ttarget.classList.remove(classRef.className);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\truntime.implicitLoop(from, function (target) {\n\t\t\t\t\t\t\t\ttarget.removeAttribute(attributeRef.name);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"toggle\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"toggle\")) {\n\t\t\tif (tokens.matchToken(\"between\")) {\n\t\t\t\tvar between = true;\n\t\t\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\t\t\ttokens.requireToken(\"and\");\n\t\t\t\tvar classRef2 = parser.requireElement(\"classRef\", tokens);\n\t\t\t} else {\n\t\t\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\t\t\tvar attributeRef = null;\n\t\t\t\tif (classRef == null) {\n\t\t\t\t\tattributeRef = parser.parseElement(\"attributeRef\", tokens);\n\t\t\t\t\tif (attributeRef == null) {\n\t\t\t\t\t\tparser.raiseParseError(tokens, \"Expected either a class reference or attribute expression\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar classRefs = [classRef];\n\t\t\t\t\twhile ((classRef = parser.parseElement(\"classRef\", tokens))) {\n\t\t\t\t\t\tclassRefs.push(classRef);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"on\")) {\n\t\t\t\tvar on = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar on = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"for\")) {\n\t\t\t\tvar time = parser.requireElement(\"timeExpression\", tokens);\n\t\t\t} else if (tokens.matchToken(\"until\")) {\n\t\t\t\tvar evt = parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\");\n\t\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\t\tvar from = parser.requireElement(\"expression\", tokens);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar toggleCmd = {\n\t\t\t\tclassRef: classRef,\n\t\t\t\tclassRef2: classRef2,\n\t\t\t\tclassRefs: classRefs,\n\t\t\t\tattributeRef: attributeRef,\n\t\t\t\ton: on,\n\t\t\t\ttime: time,\n\t\t\t\tevt: evt,\n\t\t\t\tfrom: from,\n\t\t\t\ttoggle: function (on, classRef, classRef2, classRefs) {\n\t\t\t\t\tif (between) {\n\t\t\t\t\t\truntime.implicitLoop(on, function (target) {\n\t\t\t\t\t\t\tif (target.classList.contains(classRef.className)) {\n\t\t\t\t\t\t\t\ttarget.classList.remove(classRef.className);\n\t\t\t\t\t\t\t\ttarget.classList.add(classRef2.className);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget.classList.add(classRef.className);\n\t\t\t\t\t\t\t\ttarget.classList.remove(classRef2.className);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (classRefs) {\n\t\t\t\t\t\truntime.forEach(classRefs, function (classRef) {\n\t\t\t\t\t\t\truntime.implicitLoop(on, function (target) {\n\t\t\t\t\t\t\t\ttarget.classList.toggle(classRef.className);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\truntime.forEach(on, function (target) {\n\t\t\t\t\t\t\tif (target.hasAttribute(attributeRef.name)) {\n\t\t\t\t\t\t\t\ttarget.removeAttribute(attributeRef.name);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget.setAttribute(attributeRef.name, attributeRef.value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\targs: [on, time, evt, from, classRef, classRef2, classRefs],\n\t\t\t\top: function (context, on, time, evt, from, classRef, classRef2, classRefs) {\n\t\t\t\t\tif (time) {\n\t\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\t\t\tresolve(runtime.findNext(toggleCmd, context));\n\t\t\t\t\t\t\t}, time);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (evt) {\n\t\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\t\tvar target = from || context.me;\n\t\t\t\t\t\t\ttarget.addEventListener(\n\t\t\t\t\t\t\t\tevt,\n\t\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\t\t\t\tresolve(runtime.findNext(toggleCmd, context));\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\treturn runtime.findNext(toggleCmd, context);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn toggleCmd;\n\t\t}\n\t});\n\n\tvar HIDE_SHOW_STRATEGIES = {\n\t\tdisplay: function (op, element, arg) {\n\t\t\tif (arg) {\n\t\t\t\telement.style.display = arg;\n\t\t\t} else if (op === \"hide\") {\n\t\t\t\tconst internalData = _hyperscript.internals.runtime.getInternalData(element);\n\t\t\t\tif (internalData.originalDisplay == null) {\n\t\t\t\t\tinternalData.originalDisplay = element.style.display;\n\t\t\t\t}\n\t\t\t\telement.style.display = \"none\";\n\t\t\t} else {\n\t\t\t\tconst internalData = _hyperscript.internals.runtime.getInternalData(element);\n\t\t\t\tif (internalData.originalDisplay) {\n\t\t\t\t\telement.style.display = internalData.originalDisplay;\n\t\t\t\t} else {\n\t\t\t\t\telement.style.removeProperty('display');\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tvisibility: function (op, element, arg) {\n\t\t\tif (arg) {\n\t\t\t\telement.style.visibility = arg;\n\t\t\t} else if (op === \"hide\") {\n\t\t\t\telement.style.visibility = \"hidden\";\n\t\t\t} else {\n\t\t\t\telement.style.visibility = \"visible\";\n\t\t\t}\n\t\t},\n\t\topacity: function (op, element, arg) {\n\t\t\tif (arg) {\n\t\t\t\telement.style.opacity = arg;\n\t\t\t} else if (op === \"hide\") {\n\t\t\t\telement.style.opacity = \"0\";\n\t\t\t} else {\n\t\t\t\telement.style.opacity = \"1\";\n\t\t\t}\n\t\t},\n\t};\n\n\tvar parseShowHideTarget = function (parser, runtime, tokens) {\n\t\tvar target;\n\t\tvar currentTokenValue = tokens.currentToken();\n\t\tif (currentTokenValue.value === \"when\" || currentTokenValue.value === \"with\" || parser.commandBoundary(currentTokenValue)) {\n\t\t\ttarget = parser.parseElement(\"implicitMeTarget\", tokens);\n\t\t} else {\n\t\t\ttarget = parser.parseElement(\"expression\", tokens);\n\t\t}\n\t\treturn target;\n\t};\n\n\tvar resolveStrategy = function (parser, tokens, name) {\n\t\tvar configDefault = _hyperscript.config.defaultHideShowStrategy;\n\t\tvar strategies = HIDE_SHOW_STRATEGIES;\n\t\tif (_hyperscript.config.hideShowStrategies) {\n\t\t\tstrategies = mergeObjects(strategies, _hyperscript.config.hideShowStrategies); // merge in user provided strategies\n\t\t}\n\t\tname = name || configDefault || \"display\";\n\t\tvar value = strategies[name];\n\t\tif (value == null) {\n\t\t\tparser.raiseParseError(tokens, \"Unknown show/hide strategy : \" + name);\n\t\t}\n\t\treturn value;\n\t};\n\n\t_hyperscript.addCommand(\"hide\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"hide\")) {\n\t\t\tvar target = parseShowHideTarget(parser, runtime, tokens);\n\n\t\t\tvar name = null;\n\t\t\tif (tokens.matchToken(\"with\")) {\n\t\t\t\tname = tokens.requireTokenType(\"IDENTIFIER\").value;\n\t\t\t}\n\t\t\tvar hideShowStrategy = resolveStrategy(parser, tokens, name);\n\n\t\t\treturn {\n\t\t\t\ttarget: target,\n\t\t\t\targs: [target],\n\t\t\t\top: function (ctx, target) {\n\t\t\t\t\truntime.implicitLoop(target, function (elt) {\n\t\t\t\t\t\thideShowStrategy(\"hide\", elt);\n\t\t\t\t\t});\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"show\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"show\")) {\n\t\t\tvar target = parseShowHideTarget(parser, runtime, tokens);\n\n\t\t\tvar name = null;\n\t\t\tif (tokens.matchToken(\"with\")) {\n\t\t\t\tname = tokens.requireTokenType(\"IDENTIFIER\").value;\n\t\t\t}\n\t\t\tvar arg = null;\n\t\t\tif (tokens.matchOpToken(\":\")) {\n\t\t\t\tvar tokenArr = tokens.consumeUntilWhitespace();\n\t\t\t\ttokens.matchTokenType(\"WHITESPACE\");\n\t\t\t\targ = tokenArr\n\t\t\t\t\t.map(function (t) {\n\t\t\t\t\t\treturn t.value;\n\t\t\t\t\t})\n\t\t\t\t\t.join(\"\");\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"when\")) {\n\t\t\t\tvar when = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\n\t\t\tvar hideShowStrategy = resolveStrategy(parser, tokens, name);\n\n\t\t\treturn {\n\t\t\t\ttarget: target,\n\t\t\t\twhen: when,\n\t\t\t\targs: [target],\n\t\t\t\top: function (ctx, target) {\n\t\t\t\t\truntime.implicitLoop(target, function (elt) {\n\t\t\t\t\t\tif (when) {\n\t\t\t\t\t\t\tctx['result'] = elt;\n\t\t\t\t\t\t\tlet whenResult = runtime.evaluateNoPromise(when, ctx);\n\t\t\t\t\t\t\tif (whenResult) {\n\t\t\t\t\t\t\t\thideShowStrategy(\"show\", elt, arg);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\thideShowStrategy(\"hide\", elt);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tctx['result'] = null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thideShowStrategy(\"show\", elt, arg);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"take\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"take\")) {\n\t\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tvar from = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar from = classRef;\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"for\")) {\n\t\t\t\tvar forElt = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar forElt = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tvar takeCmd = {\n\t\t\t\tclassRef: classRef,\n\t\t\t\tfrom: from,\n\t\t\t\tforElt: forElt,\n\t\t\t\targs: [classRef, from, forElt],\n\t\t\t\top: function (context, eltColl, from, forElt) {\n\t\t\t\t\tvar clazz = eltColl.className;\n\t\t\t\t\truntime.implicitLoop(from, function (target) {\n\t\t\t\t\t\ttarget.classList.remove(clazz);\n\t\t\t\t\t});\n\t\t\t\t\truntime.implicitLoop(forElt, function (target) {\n\t\t\t\t\t\ttarget.classList.add(clazz);\n\t\t\t\t\t});\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn takeCmd;\n\t\t}\n\t});\n\n\tfunction putInto(runtime, context, prop, valueToPut) {\n\t\tif (prop) {\n\t\t\tvar value = runtime.resolveSymbol(prop, context);\n\t\t} else {\n\t\t\tvar value = context;\n\t\t}\n\t\tif (value instanceof Element || value instanceof HTMLDocument) {\n\t\t\twhile (value.firstChild) value.removeChild(value.firstChild);\n\t\t\tvalue.append(_hyperscript.internals.runtime.convertValue(valueToPut, \"Fragment\"));\n\t\t} else {\n\t\t\tif (prop) {\n\t\t\t\truntime.setSymbol(prop, context, null, valueToPut);\n\t\t\t} else {\n\t\t\t\tthrow \"Don't know how to put a value into \" + typeof context;\n\t\t\t}\n\t\t}\n\t}\n\n\t_hyperscript.addCommand(\"put\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"put\")) {\n\t\t\tvar value = parser.requireElement(\"expression\", tokens);\n\n\t\t\tvar operationToken = tokens.matchAnyToken(\"into\", \"before\", \"after\");\n\n\t\t\tif (operationToken == null && tokens.matchToken(\"at\")) {\n\t\t\t\ttokens.matchToken(\"the\"); // optional \"the\"\n\t\t\t\toperationToken = tokens.matchAnyToken(\"start\", \"end\");\n\t\t\t\ttokens.requireToken(\"of\");\n\t\t\t}\n\n\t\t\tif (operationToken == null) {\n\t\t\t\tparser.raiseParseError(tokens, \"Expected one of 'into', 'before', 'at start of', 'at end of', 'after'\");\n\t\t\t}\n\t\t\tvar target = parser.requireElement(\"expression\", tokens);\n\n\t\t\tvar operation = operationToken.value;\n\n\t\t\tvar symbolWrite = false;\n\t\t\tvar rootExpr = null;\n\t\t\tvar prop = null;\n\t\t\tif (target.prop && target.root && operation === \"into\") {\n\t\t\t\tprop = target.prop.value;\n\t\t\t\trootExpr = target.root;\n\t\t\t} else if (target.type === \"symbol\" && operation === \"into\") {\n\t\t\t\tsymbolWrite = true;\n\t\t\t\tprop = target.name;\n\t\t\t} else if (target.type === \"attributeRef\" && operation === \"into\") {\n\t\t\t\tvar attributeWrite = true;\n\t\t\t\tprop = target.name;\n\t\t\t\trootExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t} else if (target.attribute && operation === \"into\") {\n\t\t\t\tvar attributeWrite = true;\n\t\t\t\tprop = target.attribute.name;\n\t\t\t\trootExpr = target.root;\n\t\t\t} else {\n\t\t\t\trootExpr = target;\n\t\t\t}\n\n\t\t\tvar putCmd = {\n\t\t\t\ttarget: target,\n\t\t\t\toperation: operation,\n\t\t\t\tsymbolWrite: symbolWrite,\n\t\t\t\tvalue: value,\n\t\t\t\targs: [rootExpr, value],\n\t\t\t\top: function (context, root, valueToPut) {\n\t\t\t\t\tif (symbolWrite) {\n\t\t\t\t\t\tputInto(runtime, context, prop, valueToPut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (operation === \"into\") {\n\t\t\t\t\t\t\tif (attributeWrite) {\n\t\t\t\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\t\t\t\telt.setAttribute(prop, valueToPut);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\t\t\t\tputInto(runtime, elt, prop, valueToPut);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar op =\n\t\t\t\t\t\t\t\toperation === \"before\"\n\t\t\t\t\t\t\t\t\t? Element.prototype.before\n\t\t\t\t\t\t\t\t\t: operation === \"after\"\n\t\t\t\t\t\t\t\t\t? Element.prototype.after\n\t\t\t\t\t\t\t\t\t: operation === \"start\"\n\t\t\t\t\t\t\t\t\t? Element.prototype.prepend\n\t\t\t\t\t\t\t\t\t: operation === \"end\"\n\t\t\t\t\t\t\t\t\t? Element.prototype.append\n\t\t\t\t\t\t\t\t\t: Element.prototype.append; // unreachable\n\n\t\t\t\t\t\t\tif (root) {\n\t\t\t\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\t\t\t\top.call(\n\t\t\t\t\t\t\t\t\t\telt,\n\t\t\t\t\t\t\t\t\t\tvalueToPut instanceof Node\n\t\t\t\t\t\t\t\t\t\t\t? valueToPut\n\t\t\t\t\t\t\t\t\t\t\t: runtime.convertValue(valueToPut, \"Fragment\")\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn putCmd;\n\t\t}\n\t});\n\n\tfunction parsePseudopossessiveTarget(parser, runtime, tokens) {\n\t\tvar targets;\n\t\tif (\n\t\t\ttokens.matchToken(\"the\") ||\n\t\t\ttokens.matchToken(\"element\") ||\n\t\t\ttokens.matchToken(\"elements\") ||\n\t\t\ttokens.currentToken().type === \"CLASS_REF\" ||\n\t\t\ttokens.currentToken().type === \"ID_REF\" ||\n\t\t\t(tokens.currentToken().op && tokens.currentToken().value === \"<\")\n\t\t) {\n\t\t\tparser.possessivesDisabled = true;\n\t\t\ttry {\n\t\t\t\ttargets = parser.parseElement(\"expression\", tokens);\n\t\t\t} finally {\n\t\t\t\tdelete parser.possessivesDisabled;\n\t\t\t}\n\t\t\t// optional possessive\n\t\t\tif (tokens.matchOpToken(\"'\")) {\n\t\t\t\ttokens.requireToken(\"s\");\n\t\t\t}\n\t\t} else if (tokens.currentToken().type === \"IDENTIFIER\" && tokens.currentToken().value === \"its\") {\n\t\t\tvar identifier = tokens.matchToken(\"its\");\n\t\t\ttargets = {\n\t\t\t\ttype: \"pseudopossessiveIts\",\n\t\t\t\ttoken: identifier,\n\t\t\t\tname: identifier.value,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.resolveSymbol(\"it\", context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\ttokens.matchToken(\"my\") || tokens.matchToken(\"me\"); // consume optional 'my'\n\t\t\ttargets = parser.parseElement(\"implicitMeTarget\", tokens);\n\t\t}\n\t\treturn targets;\n\t}\n\n\t_hyperscript.addCommand(\"transition\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"transition\")) {\n\t\t\tvar targets = parsePseudopossessiveTarget(parser, runtime, tokens);\n\n\t\t\tvar properties = [];\n\t\t\tvar from = [];\n\t\t\tvar to = [];\n\t\t\tvar currentToken = tokens.currentToken();\n\t\t\twhile (\n\t\t\t\t!parser.commandBoundary(currentToken) &&\n\t\t\t\tcurrentToken.value !== \"over\" &&\n\t\t\t\tcurrentToken.value !== \"using\"\n\t\t\t) {\n\t\t\t\tproperties.push(parser.requireElement(\"stringLike\", tokens));\n\n\t\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\t\tfrom.push(parser.requireElement(\"stringLike\", tokens));\n\t\t\t\t} else {\n\t\t\t\t\tfrom.push(null);\n\t\t\t\t}\n\t\t\t\ttokens.requireToken(\"to\");\n\t\t\t\tto.push(parser.requireElement(\"stringLike\", tokens));\n\t\t\t\tcurrentToken = tokens.currentToken();\n\t\t\t}\n\t\t\tif (tokens.matchToken(\"over\")) {\n\t\t\t\tvar over = parser.requireElement(\"timeExpression\", tokens);\n\t\t\t} else if (tokens.matchToken(\"using\")) {\n\t\t\t\tvar using = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\n\t\t\tvar transition = {\n\t\t\t\tto: to,\n\t\t\t\targs: [targets, properties, from, to, using, over],\n\t\t\t\top: function (context, targets, properties, from, to, using, over) {\n\t\t\t\t\tvar promises = [];\n\t\t\t\t\truntime.implicitLoop(targets, function (target) {\n\t\t\t\t\t\tvar promise = new Promise(function (resolve, reject) {\n\t\t\t\t\t\t\tvar initialTransition = target.style.transition;\n\t\t\t\t\t\t\tif (over) {\n\t\t\t\t\t\t\t\ttarget.style.transition = \"all \" + over + \"ms ease-in\";\n\t\t\t\t\t\t\t} else if (using) {\n\t\t\t\t\t\t\t\ttarget.style.transition = using;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget.style.transition = _hyperscript.config.defaultTransition;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar internalData = runtime.getInternalData(target);\n\t\t\t\t\t\t\tvar computedStyles = getComputedStyle(target);\n\n\t\t\t\t\t\t\tvar initialStyles = {};\n\t\t\t\t\t\t\tfor (var i = 0; i < computedStyles.length; i++) {\n\t\t\t\t\t\t\t\tvar name = computedStyles[i];\n\t\t\t\t\t\t\t\tvar initialValue = computedStyles[name];\n\t\t\t\t\t\t\t\tinitialStyles[name] = initialValue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// store intitial values\n\t\t\t\t\t\t\tif (!internalData.initalStyles) {\n\t\t\t\t\t\t\t\tinternalData.initalStyles = initialStyles;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (var i = 0; i < properties.length; i++) {\n\t\t\t\t\t\t\t\tvar property = properties[i];\n\t\t\t\t\t\t\t\tvar fromVal = from[i];\n\t\t\t\t\t\t\t\tif (fromVal == \"computed\" || fromVal == null) {\n\t\t\t\t\t\t\t\t\ttarget.style[property] = initialStyles[property];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttarget.style[property] = fromVal;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// console.log(\"transition started\", transition);\n\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\tvar autoProps = [];\n\t\t\t\t\t\t\t\tfor (var i = 0; i < properties.length; i++) {\n\t\t\t\t\t\t\t\t\tvar property = properties[i];\n\t\t\t\t\t\t\t\t\tvar toVal = to[i];\n\t\t\t\t\t\t\t\t\tif (toVal == \"initial\") {\n\t\t\t\t\t\t\t\t\t\tvar propertyValue = internalData.initalStyles[property];\n\t\t\t\t\t\t\t\t\t\ttarget.style[property] = propertyValue;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ttarget.style[property] = toVal;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// console.log(\"set\", property, \"to\", target.style[property], \"on\", target, \"value passed in : \", toVal);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttarget.addEventListener(\n\t\t\t\t\t\t\t\t\t\"transitionend\",\n\t\t\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\t\t\t// console.log(\"transition ended\", transition);\n\t\t\t\t\t\t\t\t\t\ttarget.style.transition = initialTransition;\n\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}, 5);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tpromises.push(promise);\n\t\t\t\t\t});\n\t\t\t\t\treturn Promise.all(promises).then(function () {\n\t\t\t\t\t\treturn runtime.findNext(transition, context);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn transition;\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"measure\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"measure\")) return;\n\n\t\tvar target = parsePseudopossessiveTarget(parser, runtime, tokens);\n\n\t\tvar propsToMeasure = [];\n\t\tif (!parser.commandBoundary(tokens.currentToken()))\n\t\t\tdo {\n\t\t\t\tpropsToMeasure.push(tokens.matchTokenType(\"IDENTIFIER\").value);\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\n\t\treturn {\n\t\t\tproperties: propsToMeasure,\n\t\t\targs: [target],\n\t\t\top: function (ctx, target) {\n\t\t\t\tif (0 in target) target = target[0]; // not measuring multiple elts\n\t\t\t\tvar rect = target.getBoundingClientRect();\n\t\t\t\tvar scroll = {\n\t\t\t\t\ttop: target.scrollTop,\n\t\t\t\t\tleft: target.scrollLeft,\n\t\t\t\t\ttopMax: target.scrollTopMax,\n\t\t\t\t\tleftMax: target.scrollLeftMax,\n\t\t\t\t\theight: target.scrollHeight,\n\t\t\t\t\twidth: target.scrollWidth,\n\t\t\t\t};\n\n\t\t\t\tctx.result = {\n\t\t\t\t\tx: rect.x,\n\t\t\t\t\ty: rect.y,\n\t\t\t\t\tleft: rect.left,\n\t\t\t\t\ttop: rect.top,\n\t\t\t\t\tright: rect.right,\n\t\t\t\t\tbottom: rect.bottom,\n\t\t\t\t\twidth: rect.width,\n\t\t\t\t\theight: rect.height,\n\t\t\t\t\tbounds: rect,\n\n\t\t\t\t\tscrollLeft: scroll.left,\n\t\t\t\t\tscrollTop: scroll.top,\n\t\t\t\t\tscrollLeftMax: scroll.leftMax,\n\t\t\t\t\tscrollTopMax: scroll.topMax,\n\t\t\t\t\tscrollWidth: scroll.width,\n\t\t\t\t\tscrollHeight: scroll.height,\n\t\t\t\t\tscroll: scroll,\n\t\t\t\t};\n\n\t\t\t\truntime.forEach(propsToMeasure, function (prop) {\n\t\t\t\t\tif (prop in ctx.result) ctx[prop] = ctx.result[prop];\n\t\t\t\t\telse throw \"No such measurement as \" + prop;\n\t\t\t\t});\n\n\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t},\n\t\t};\n\t});\n\n\t_hyperscript.addLeafExpression(\"closestExpr\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"closest\")) {\n\t\t\tif (tokens.matchToken(\"parent\")) {\n\t\t\t\tvar parentSearch = true;\n\t\t\t}\n\n\t\t\tvar css = null;\n\t\t\tif (tokens.currentToken().type === \"ATTRIBUTE_REF\") {\n\t\t\t\tvar attributeRef = parser.parseElement(\"attributeRefAccess\", tokens, null);\n\t\t\t\tcss = \"[\" + attributeRef.attribute.name + \"]\";\n\t\t\t}\n\n\t\t\tif (css == null) {\n\t\t\t\tvar expr = parser.parseElement(\"expression\", tokens);\n\t\t\t\tif (expr.css == null) {\n\t\t\t\t\tparser.raiseParseError(tokens, \"Expected a CSS expression\");\n\t\t\t\t} else {\n\t\t\t\t\tcss = expr.css;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"to\")) {\n\t\t\t\tvar to = parser.parseElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar to = parser.parseElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tvar closestExpr = {\n\t\t\t\ttype: \"closestExpr\",\n\t\t\t\tparentSearch: parentSearch,\n\t\t\t\texpr: expr,\n\t\t\t\tcss: css,\n\t\t\t\tto: to,\n\t\t\t\targs: [to],\n\t\t\t\top: function (ctx, to) {\n\t\t\t\t\tif (to == null || !(to instanceof Element)) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (parentSearch) {\n\t\t\t\t\t\t\tvar node = to.parentElement ? to.parentElement.closest(css) : null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar node = to.closest(css);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tif (attributeRef) {\n\t\t\t\tattributeRef.root = closestExpr;\n\t\t\t\tattributeRef.args = [closestExpr];\n\t\t\t\treturn attributeRef;\n\t\t\t} else {\n\t\t\t\treturn closestExpr;\n\t\t\t}\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"go\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"go\")) {\n\t\t\tif (tokens.matchToken(\"back\")) {\n\t\t\t\tvar back = true;\n\t\t\t} else {\n\t\t\t\ttokens.matchToken(\"to\");\n\t\t\t\tif (tokens.matchToken(\"url\")) {\n\t\t\t\t\tvar target = parser.requireElement(\"stringLike\", tokens);\n\t\t\t\t\tvar url = true;\n\t\t\t\t\tif (tokens.matchToken(\"in\")) {\n\t\t\t\t\t\ttokens.requireToken(\"new\");\n\t\t\t\t\t\ttokens.requireToken(\"window\");\n\t\t\t\t\t\tvar newWindow = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttokens.matchToken(\"the\"); // optional the\n\t\t\t\t\tvar verticalPosition = tokens.matchAnyToken(\"top\", \"bottom\", \"middle\");\n\t\t\t\t\tvar horizontalPosition = tokens.matchAnyToken(\"left\", \"center\", \"right\");\n\t\t\t\t\tif (verticalPosition || horizontalPosition) {\n\t\t\t\t\t\ttokens.requireToken(\"of\");\n\t\t\t\t\t}\n\t\t\t\t\tvar target = parser.requireElement(\"expression\", tokens);\n\t\t\t\t\tvar smoothness = tokens.matchAnyToken(\"smoothly\", \"instantly\");\n\n\t\t\t\t\tvar scrollOptions = {};\n\t\t\t\t\tif (verticalPosition) {\n\t\t\t\t\t\tif (verticalPosition.value === \"top\") {\n\t\t\t\t\t\t\tscrollOptions.block = \"start\";\n\t\t\t\t\t\t} else if (verticalPosition.value === \"bottom\") {\n\t\t\t\t\t\t\tscrollOptions.block = \"end\";\n\t\t\t\t\t\t} else if (verticalPosition.value === \"middle\") {\n\t\t\t\t\t\t\tscrollOptions.block = \"center\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (horizontalPosition) {\n\t\t\t\t\t\tif (horizontalPosition.value === \"left\") {\n\t\t\t\t\t\t\tscrollOptions.inline = \"start\";\n\t\t\t\t\t\t} else if (horizontalPosition.value === \"center\") {\n\t\t\t\t\t\t\tscrollOptions.inline = \"center\";\n\t\t\t\t\t\t} else if (horizontalPosition.value === \"right\") {\n\t\t\t\t\t\t\tscrollOptions.inline = \"end\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (smoothness) {\n\t\t\t\t\t\tif (smoothness.value === \"smoothly\") {\n\t\t\t\t\t\t\tscrollOptions.behavior = \"smooth\";\n\t\t\t\t\t\t} else if (smoothness.value === \"instantly\") {\n\t\t\t\t\t\t\tscrollOptions.behavior = \"instant\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar goCmd = {\n\t\t\t\ttarget: target,\n\t\t\t\targs: [target],\n\t\t\t\top: function (ctx, to) {\n\t\t\t\t\tif (back) {\n\t\t\t\t\t\twindow.history.back();\n\t\t\t\t\t} else if (url) {\n\t\t\t\t\t\tif (to) {\n\t\t\t\t\t\t\tif (to.indexOf(\"#\") === 0 && !newWindow) {\n\t\t\t\t\t\t\t\twindow.location.href = to;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twindow.open(to, newWindow ? \"_blank\" : null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\truntime.forEach(to, function (target) {\n\t\t\t\t\t\t\ttarget.scrollIntoView(scrollOptions);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn runtime.findNext(goCmd);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn goCmd;\n\t\t}\n\t});\n\n\t_hyperscript.config.conversions[\"Values\"] = function (/** @type {Node | NodeList} */ node) {\n\t\t/** @type Object<string,string | string[]> */\n\t\tvar result = {};\n\n\t\tvar implicitLoop = _hyperscript.internals.runtime.implicitLoop;\n\n\t\timplicitLoop(node, function (/** @type HTMLInputElement */ node) {\n\t\t\t// Try to get a value directly from this node\n\t\t\tvar input = getInputInfo(node);\n\n\t\t\tif (input !== undefined) {\n\t\t\t\tresult[input.name] = input.value;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise, try to query all child elements of this node that *should* contain values.\n\t\t\tif (node.querySelectorAll != undefined) {\n\t\t\t\tvar children = node.querySelectorAll(\"input,select,textarea\");\n\t\t\t\tchildren.forEach(appendValue);\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\n\t\t/**\n\t\t * @param {HTMLInputElement} node\n\t\t */\n\t\tfunction appendValue(node) {\n\t\t\tvar info = getInputInfo(node);\n\n\t\t\tif (info == undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If there is no value already stored in this space.\n\t\t\tif (result[info.name] == undefined) {\n\t\t\t\tresult[info.name] = info.value;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Array.isArray(result[info.name]) && Array.isArray(info.value)) {\n\t\t\t\tresult[info.name] = [].concat(result[info.name], info.value);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {HTMLInputElement} node\n\t\t * @returns {{name:string, value:string | string[]} | undefined}\n\t\t */\n\t\tfunction getInputInfo(node) {\n\t\t\ttry {\n\t\t\t\t/** @type {{name: string, value: string | string[]}}*/\n\t\t\t\tvar result = {\n\t\t\t\t\tname: node.name,\n\t\t\t\t\tvalue: node.value,\n\t\t\t\t};\n\n\t\t\t\tif (result.name == undefined || result.value == undefined) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tif (node.type == \"radio\" && node.checked == false) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tif (node.type == \"checkbox\") {\n\t\t\t\t\tif (node.checked == false) {\n\t\t\t\t\t\tresult.value = undefined;\n\t\t\t\t\t} else if (typeof result.value === \"string\") {\n\t\t\t\t\t\tresult.value = [result.value];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (node.type == \"select-multiple\") {\n\t\t\t\t\t/** @type {NodeListOf<HTMLSelectElement>} */\n\t\t\t\t\tvar selected = node.querySelectorAll(\"option[selected]\");\n\n\t\t\t\t\tresult.value = [];\n\t\t\t\t\tfor (var index = 0; index < selected.length; index++) {\n\t\t\t\t\t\tresult.value.push(selected[index].value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} catch (e) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t};\n\n\t_hyperscript.config.conversions[\"HTML\"] = function (value) {\n\t\tvar toHTML = /** @returns {string}*/ function (/** @type any*/ value) {\n\t\t\tif (value instanceof Array) {\n\t\t\t\treturn value\n\t\t\t\t\t.map(function (item) {\n\t\t\t\t\t\treturn toHTML(item);\n\t\t\t\t\t})\n\t\t\t\t\t.join(\"\");\n\t\t\t}\n\n\t\t\tif (value instanceof HTMLElement) {\n\t\t\t\treturn value.outerHTML;\n\t\t\t}\n\n\t\t\tif (value instanceof NodeList) {\n\t\t\t\tvar result = \"\";\n\t\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\t\tvar node = value[i];\n\t\t\t\t\tif (node instanceof HTMLElement) {\n\t\t\t\t\t\tresult += node.outerHTML;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tif (value.toString) {\n\t\t\t\treturn value.toString();\n\t\t\t}\n\n\t\t\treturn \"\";\n\t\t};\n\n\t\treturn toHTML(value);\n\t};\n\n\t_hyperscript.config.conversions[\"Fragment\"] = function (val) {\n\t\tvar frag = document.createDocumentFragment();\n\t\t_hyperscript.internals.runtime.implicitLoop(val, function (val) {\n\t\t\tif (val instanceof Node) frag.append(val);\n\t\t\telse {\n\t\t\t\tvar temp = document.createElement(\"template\");\n\t\t\t\ttemp.innerHTML = val;\n\t\t\t\tfrag.append(temp.content);\n\t\t\t}\n\t\t});\n\t\treturn frag;\n\t};\n}\n","\nimport _hyperscript from \"../lib/core.js\"\n\nimport web from \"../lib/web.js\"\n\nweb(_hyperscript)\n\nexport default _hyperscript\n"],"names":["mergeObjects","obj1","obj2","key","hasOwnProperty","getOrInitObject","root","prop","value","newObj","varargConstructor","Cls","args","bind","apply","concat","_hyperscript","globalScope","globalThis","ElementCollection","css","relativeToElement","this","_css","contains","elt","_runtime","getRootNode","querySelectorAll","Symbol","iterator","escapeSelector","substr","className","_lexer","OP_TABLE","$","isValidCSSClassChar","c","isAlpha","isNumeric","isValidCSSIDChar","isWhitespace","isNewline","isIdentifierChar","dollarIsOp","makeTokensObject","tokens","consumed","source","consumeWhitespace","_lastConsumed","token","type","push","shift","raiseError","error","_parser","raiseParseError","matchOpToken","currentToken","op","consumeToken","matchTokenType","type1","type2","type3","type4","indexOf","matchToken","follows","match","consumeUntil","tokenList","n","dontIgnoreWhitespace","i","pushFollow","str","popFollow","pop","clearFollow","tmp","restoreFollow","f","matchAnyToken","op1","op2","op3","arguments","length","opToken","matchAnyOpToken","requireOpToken","requireTokenType","JSON","stringify","requireToken","list","hasMore","lastMatch","consumeUntilWhitespace","lastWhitespace","sourceFor","substring","startToken","start","endToken","end","lineFor","split","line","isValidSingleQuoteStringStart","previousToken","tokenize","string","template","position","column","lastToken","templateBraceCount","inTemplate","currentChar","nextChar","charAfterThat","possiblePrecedingSymbol","consumeAttributeReference","consumeShortAttributeReference","consumeIdentifier","consumeNumber","consumeOp","makeToken","consumeChar","Error","consumeString","consumeIdReference","consumeClassReference","consumeComment","classRef","attributeRef","idRef","identifier","number","makeOpToken","startChar","charAt","whitespace","GRAMMAR","COMMANDS","FEATURES","LEAF_EXPRESSIONS","INDIRECT_EXPRESSIONS","initElt","parseElement","programSource","undefined","elementDefinition","requireElement","message","result","parseAnyOf","types","expression","addGrammarElement","name","definition","lines","contextLine","repeat","createParserContext","commandStart","featureStart","parser","runtime","featureElement","featureDefinition","commandElement","commandDefinition","cmd","next","indirect","unless","context","conditional","execute","unifiedExec","parent","leaf","setParent","commandBoundary","parseHyperScript","addCommand","keyword","commandGrammarType","commandDefinitionWrapper","meta","command","addFeature","featureGrammarType","featureDefinitionWrapper","addLeafExpression","addIndirectExpression","parseStringTemplate","returnArr","startingBrace","CONVERSIONS","dynamicResolvers","String","val","toString","Int","parseInt","Float","parseFloat","Number","console","log","Date","Array","from","Object","parse","matchesSelector","selector","matchesFunction","matches","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","oMatchesSelector","call","triggerEvent","eventName","detail","event","evt","Event","bubbles","cancelable","document","createEvent","initCustomEvent","makeEvent","dispatchEvent","isArrayLike","isArray","NodeList","shouldAutoIterate","forEach","func","isIterable","ARRAY_SENTINEL","array_sentinel","unwrapAsyncs","values","asyncWrapper","j","valueElement","HALT","ctx","unifiedEval","e","registerHyperTrace","errorHandler","handlingError","errorSymmbol","reject","then","resolvedNext","reason","async","wrappedAsyncs","argument","arr","element","evaluate","Promise","resolve","linearized","arg","linearize","all","valueArray","delinearize","_scriptAttrs","getScriptAttributes","config","attributes","replace","getScript","scriptAttribute","hasAttribute","getAttribute","HTMLScriptElement","innerText","hyperscriptFeaturesMap","WeakMap","getHyperscriptFeatures","hyperscriptFeatures","get","set","addFeatures","owner","parentElement","makeContext","feature","hyperscriptTarget","lexer","iterators","me","target","body","src","commandList","last","initElement","closest","disableSelector","internalData","getInternalData","initialized","script","hyperScript","setTimeout","hyperscript","stack","internalDataMap","getElementScope","scopeName","behavior","typeCheck","typeString","nullOk","prototype","slice","implicitLoop","processNode","getScriptSelector","HyperscriptModule","mod","_this","module","id","EventTarget","evaluateNoPromise","map","attribute","join","resolveSymbol","fromMetaContext","fromContext","setSymbol","elementScope","findNext","resolveNext","convertValue","converted","dynamicResolver","converter","resolveProperty","property","component","componentValue","assignToNamespace","nameSpace","propertyName","newRoot","thrown","trace","caller","traceMap","Map","print","logger","maxLen","Math","max","displayName","traceElt","padEnd","getHyperTrace","nullCheck","isEmpty","node","rv","Document","ShadowRoot","hyperscriptUrl","import","url","sloppyContains","container","includes","sloppyMatches","toMatch","parseSendCmd","cmdType","details","to","sendCmd","expr","stringToken","rawValue","innerTokens","returnStr","tokenArr","t","numberToken","elementId","templateValue","getElementById","TemplatedQueryElementCollection","templateParts","_this2","elements","filter","Element","el","dataset","hsQueryId","removeAttribute","queryTokens","queryValue","outerVal","innerValue","beingTold","keyExpressions","valueExpressions","keys","returnVal","fields","_namedArgList_","symbolType","booleanLiteral","arg1","time","factor","_context","rootVal","childOfUrRoot","urRoot","propertyAccess","possessivesDisabled","apostrophe","query","targetElt","results","rootElt","conversion","functionCall","argExressions","rootRoot","hyperfunc","argVals","_ctx","andBefore","andAfter","firstIndex","secondIndex","arrayIndex","typeName","scanForwardArray","array","wrap","first","forwardSearch","thing","withinElt","inSearch","inElt","wrapping","operator","reverse","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","scanForwardQuery","DOCUMENT_POSITION_FOLLOWING","scanBackwardsQuery","rhs","rhsVal","children","floor","random","mathOp","initialMathOp","lhs","lhsVal","comparisonToken","hasRightValue","logicalOp","initialLogicalOp","features","install","parseEventArgs","every","events","startCountToken","startCount","endCountToken","endCount","unbounded","intersectionSpec","mutationSpec","elsewhere","inExpr","debounceTime","throttleTime","execCount","on","debounced","lastExec","queue","queueLast","queueFirst","queueNone","implicitReturn","onFeature","executing","queued","err","hypertrace","eventSpec","targets","MutationObserver","mutationList","observer","observe","IntersectionObserver","entries","entry","isIntersecting","addEventListener","listener","isConnected","removeEventListener","initialCtx","inElement","clearTimeout","now","nameVal","funcName","errorSymbol","functionFeature","argumentVal","callingCommand","promise","theResolve","theReject","returned","returnValue","hypername","initFeature","path","formalParams","hs","innerArgs","installFeature","behaviorPath","behaviorNamespace","Function","jsSourceStart","jsLastToken","funcNames","expectFunctionDeclaration","peek","exposedFunctionNames","jsSource","jsBody","function","inputs","inp","input","actualResult","slot","tellCmd","index","originalBeingTold","lookahead","resolved","eventInfo","_this3","once","timeValue","_this4","separator","parseReturnFunction","returnAValue","returnCmd","keepExecuting","bubbling","haltDefault","exit","stopPropagation","preventDefault","exprs","withExpr","logCmd","throwCmd","parseCallOrGet","callCmd","tagname","classes","re","exec","trim","createElement","classList","add","functionName","pseudoCommand","makeSetter","symbolWrite","attributeWrite","setCmd","valueToSet","setAttribute","setter","defaultCmd","obj","objectLiteral","trueBranch","falseBranch","ifCmd","exprValue","parseRepeatExpression","startedWithForToken","innerStartToken","identifierToken","whileExpr","isUntil","times","forever","indexIdentifier","loop","waitATick","repeatCmd","until","whileValue","iteratorInfo","keepLooping","loopVal","eventFired","nextValFromIterator","done","repeatInit","innerHTML","amount","targetValue","newValue","fetchCmd","argExpressions","fetch","resp","json","text","scripts","res","code","fn","metaConfig","querySelector","jString","msg","parseJSON","content","documentElement","readyState","internals","defaultTransition","conversions","settleCommand","transitionStarted","r","cssDeclaration","classRefs","attrRef","style","cssText","stringParts","opencurly","tok","part","idx","elementExpr","removeChild","remove","between","classRef2","toggleCmd","toggle","HIDE_SHOW_STRATEGIES","display","originalDisplay","removeProperty","visibility","opacity","parseShowHideTarget","currentTokenValue","resolveStrategy","configDefault","defaultHideShowStrategy","strategies","hideShowStrategies","putInto","valueToPut","HTMLDocument","firstChild","append","parsePseudopossessiveTarget","hideShowStrategy","when","forElt","takeCmd","eltColl","clazz","operationToken","operation","rootExpr","before","after","prepend","properties","over","using","transition","promises","initialTransition","computedStyles","getComputedStyle","initialStyles","initalStyles","fromVal","toVal","propsToMeasure","rect","getBoundingClientRect","scroll","top","scrollTop","left","scrollLeft","topMax","scrollTopMax","leftMax","scrollLeftMax","height","scrollHeight","width","scrollWidth","x","y","right","bottom","bounds","parentSearch","closestExpr","back","newWindow","verticalPosition","horizontalPosition","smoothness","scrollOptions","block","inline","goCmd","window","history","open","location","href","scrollIntoView","getInputInfo","appendValue","info","checked","selected","toHTML","item","HTMLElement","outerHTML","frag","createDocumentFragment","temp","web"],"mappings":"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"}